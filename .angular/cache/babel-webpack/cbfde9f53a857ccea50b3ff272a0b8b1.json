{
  "ast": null,
  "code": "import { of, combineLatest, forkJoin, from, noop } from 'rxjs';\nimport { map, mergeMap, tap, take, switchMap, catchError, filter, startWith } from 'rxjs/operators';\nimport { doc, collection, writeBatch, DocumentReference, query, getDocs, where, orderBy, limit, limitToLast, startAt, startAfter, endAt, endBefore, getFirestore, getDoc, addDoc, setDoc, deleteDoc, updateDoc, connectFirestoreEmulator } from 'firebase/firestore';\nimport * as i0 from '@angular/core';\nimport { NgModule, Optional, SkipSelf, Injectable, Inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport firebase, { initializeApp } from 'firebase/app';\n/** Helper method to get reference from path, the path can be either to a Document or Collection */\n\nfunction getRefFromPath(path, firestore) {\n  const pathSegmentAmount = path.split('/').length;\n\n  if (pathSegmentAmount % 2 === 0) {\n    // even number means doc\n    return doc(firestore, path);\n  } else {\n    // odd meaning collection\n    return collection(firestore, path);\n  }\n}\n\nfunction getSubCollection(docRef, collectionName) {\n  const collectionPath = docRef.path.concat('/', collectionName);\n  return collection(docRef.firestore, collectionPath);\n}\n\nfunction getDocRefWithId(collectionRef, id) {\n  return doc(collectionRef.firestore, collectionRef.path, id);\n}\n/**\r\n * Add data to object inplace\r\n * @param item item to add to\r\n * @param dataToAdd data to add\r\n * @param inplace if true the data is added inplace, if false a copy is used\r\n */\n\n\nfunction addDataToItem(item, dataToAdd, inplace = false) {\n  if (inplace) {\n    Object.entries(dataToAdd).forEach(([k, v]) => {\n      item[k] = v;\n    });\n    return item;\n  } else {\n    return Object.assign(Object.assign({}, item), dataToAdd);\n  }\n}\n/**\r\n * Add createdDate to the object inplace, if createdDate already exists then we do not overwrite it\r\n *\r\n * @param item item where the createdData will be added\r\n * @param createdDate optional, will use new Date() if none given\r\n * @param inplace if true the data is added inplace, if false a copy is used\r\n */\n\n\nfunction addCreatedDate(item, inplace = false, createdDate = new Date()) {\n  // do not overwrite previous createdDate\n  if ('createdDate' in item) {\n    return item;\n  }\n\n  return addDataToItem(item, {\n    createdDate\n  }, inplace);\n}\n/**\r\n * Add modifiedDate to the object\r\n *\r\n * @param item item where the modifiedDate will be added\r\n * @param modifiedDate optional, will use new Date() if none given\r\n * @param inplace if true the data is added inplace, if false a copy is used\r\n */\n\n\nfunction addModifiedDate(item, inplace = false, modifiedDate = new Date()) {\n  return addDataToItem(item, {\n    modifiedDate\n  }, inplace);\n}\n/**\r\n * Add createdBy to the object inplace\r\n *\r\n * @param item item to add to\r\n * @param createdBy profile, user or any type of data\r\n * @param inplace if true the data is added inplace, if false a copy is used\r\n */\n\n\nfunction addCreatedBy(item, createdBy, inplace = false) {\n  return addDataToItem(item, {\n    createdBy\n  }, inplace);\n}\n/**\r\n * Firestore saves time as timestamps and javascript uses Date objects.\r\n * This functions helps convert the createdDate and modifiedDate from timestamp\r\n * to Date()\r\n *\r\n * inplace\r\n *\r\n * @param item item that contains 'createdDate' and/or 'modifiedDate'\r\n */\n\n\nfunction convertTimestampToDate(item) {\n  if (item.hasOwnProperty('createdDate')) {\n    item.createdDate = item.createdDate;\n    item.createdDate = item.createdDate.toDate();\n  }\n\n  if (item.hasOwnProperty('modifiedDate')) {\n    item.modifiedDate = item.modifiedDate;\n    item.modifiedDate = item.modifiedDate.toDate();\n  }\n\n  return item;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Moves an item one index in an array to another.\r\n * @param array Array in which to move the item.\r\n * @param fromIndex Starting index of the item.\r\n * @param toIndex Index to which the item should be moved.\r\n */\n\n\nfunction moveItemInArray(array, fromIndex, toIndex) {\n  const from = clamp(fromIndex, array.length - 1);\n  const to = clamp(toIndex, array.length - 1);\n\n  if (from === to) {\n    return;\n  }\n\n  const target = array[from];\n  const delta = to < from ? -1 : 1;\n\n  for (let i = from; i !== to; i += delta) {\n    array[i] = array[i + delta];\n  }\n\n  array[to] = target;\n}\n/**\r\n * Moves an item from one array to another.\r\n * @param currentArray Array from which to transfer the item.\r\n * @param targetArray Array into which to put the item.\r\n * @param currentIndex Index of the item in its current array.\r\n * @param targetIndex Index at which to insert the item.\r\n */\n\n\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n  const from = clamp(currentIndex, currentArray.length - 1);\n  const to = clamp(targetIndex, targetArray.length);\n\n  if (currentArray.length) {\n    targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n  }\n}\n/**\r\n * Copies an item from one array to another, leaving it in its\r\n * original position in current array.\r\n * @param currentArray Array from which to copy the item.\r\n * @param targetArray Array into which is copy the item.\r\n * @param currentIndex Index of the item in its current array.\r\n * @param targetIndex Index at which to insert the item.\r\n *\r\n */\n\n\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n  const to = clamp(targetIndex, targetArray.length);\n\n  if (currentArray.length) {\n    targetArray.splice(to, 0, currentArray[currentIndex]);\n  }\n}\n/** Clamps a number between zero and a maximum. */\n\n\nfunction clamp(value, max) {\n  return Math.max(0, Math.min(max, value));\n}\n/**\r\n * Action to be taken by listener if the document does not exist.\r\n */\n\n\nvar DocNotExistAction;\n\n(function (DocNotExistAction) {\n  /** returns a null object */\n  DocNotExistAction[DocNotExistAction[\"RETURN_NULL\"] = 0] = \"RETURN_NULL\";\n  /** return all the extras such as ref, path and so on but no data, kinda just ignores that the doc isn't there */\n\n  DocNotExistAction[DocNotExistAction[\"RETURN_ALL_BUT_DATA\"] = 1] = \"RETURN_ALL_BUT_DATA\";\n  /** do not return at all until it does exist */\n\n  DocNotExistAction[DocNotExistAction[\"FILTER\"] = 2] = \"FILTER\";\n  /** return doc not found error 'doc_not_found' */\n\n  DocNotExistAction[DocNotExistAction[\"THROW_DOC_NOT_FOUND\"] = 3] = \"THROW_DOC_NOT_FOUND\";\n})(DocNotExistAction || (DocNotExistAction = {}));\n/**\r\n * Main Class.\r\n *\r\n *\r\n *\r\n */\n\n\nclass FirestoreExtended {\n  /**\r\n   * Constructor for AngularFirestoreWrapper\r\n   *\r\n   * @param fs Firestore wrapper Firestore extended can be used by many Firestore implementations\r\n   * @param defaultDocId The default name given to a subCollection document when no name is given\r\n   */\n  constructor(fs, defaultDocId = 'data') {\n    this.fs = fs;\n    this.defaultDocId = defaultDocId;\n  }\n  /* ----------  LISTEN -------------- */\n\n  /**\r\n   *\r\n   * Allows for listening to documents and collections n deep up to the firestore max of 100 levels.\r\n   *\r\n   * Triggers for any change in any document that is listened to.\r\n   *\r\n   *\r\n   * E.x:\r\n   *      const subCollectionQueries: SubCollectionQuery[] = [\r\n   *         { name: 'data' },\r\n   *         { name: 'secure' },\r\n   *         { name: 'variants' },\r\n   *         { name: 'images',\r\n   *           queryFn: ref => ref.orderBy('index'),\r\n   *           collectionWithNames: [\r\n   *             { name: 'secure'}\r\n   *           ]\r\n   *         },\r\n   *     ];\r\n   *\r\n   *     this.listenForDocAndSubCollections<Product>(docFs, collections)\r\n   *\r\n   * Wrapper for listenForDocDeepRecursiveHelper$ so that we can cast the return to the correct type\r\n   * All logic is in listenForDocDeepRecursiveHelper$.\r\n   *\r\n   * @param docRef - a docRef with potential queryFn\r\n   * @param subCollectionQueries - see example\r\n   * @param actionIfNotExist Action to take if document does not exist\r\n   */\n\n\n  listenForDoc$(docRef, subCollectionQueries = [], actionIfNotExist = DocNotExistAction.RETURN_ALL_BUT_DATA) {\n    return this.listenForDocDeepRecursiveHelper$(docRef, subCollectionQueries, actionIfNotExist).pipe(map(data => data));\n  }\n  /**\r\n   * Same as AngularFirestoreCollection.snapshotChanges but it adds the properties in FirebaseDbItem.\r\n   *\r\n   * Important to understand this is will trigger for every change/update on any of the documents we are listening to.\r\n   * That means that if any document we are listening to is changed the entire object will be triggered containing the updated data.\r\n   *\r\n   *\r\n   *    Example usage.\r\n   *\r\n   *    ngFirestoreDeep: RxFirestoreExtended;  //  RxFirestoreExtended variable\r\n   *    restaurantCollectionFs = this.ngFireStore.collection('restaurants'); // AngularFirestoreCollectionRef to restaurants\r\n   *\r\n   *    constructor(private ngFireStore: AngularFirestore) {\r\n   *        this.ngFirestoreDeep = new RxFirestoreExtended(ngFireStore);  //  initialize AngularFireStoreDeep with AngularFirestore\r\n   *    }\r\n   *\r\n   *    listenForRestaurants$(): Observable<RestaurantItem[]> {\r\n   *        return this.ngFirestoreDeep.listenForCollection$<RestaurantItem>(this.restaurantCollectionFs);\r\n   *    }\r\n   *\r\n   *    If you do not wish to listen for changes and only care about getting the values once\r\n   *\r\n   *    getRestaurants$(): Observable<RestaurantItem[]> {\r\n   *        return this.ngFirestoreDeep.listenForCollection$<RestaurantItem>(this.restaurantCollectionFs).pipe(\r\n   *          take(1)\r\n   *        );\r\n   *    }\r\n   *\r\n   * @param _query the collectionRef which will be listened to\r\n   * @param subCollectionQueries\r\n   * @param documentChangeTypes list of DocumentChangeType that will be listened to, if null listen to all\r\n   */\n\n\n  listenForCollection$(_query, subCollectionQueries = []) {\n    /**\r\n     * Returns an observable that will emit whenever the ref changes in any way.\r\n     * Also adds the id and ref to the object.\r\n     */\n    return this.listenForCollectionSimple$(_query).pipe(mergeMap(items => {\n      if (items == null || items.length === 0) {\n        return of([]);\n      }\n\n      if (subCollectionQueries.length <= 0) {\n        return of(items);\n      }\n\n      const collectionListeners = [];\n      items.forEach(item => {\n        const collectionListener = this.listenForCollectionsDeep(item, subCollectionQueries);\n        collectionListeners.push(collectionListener);\n      });\n      /* Finally return the combined collection listeners */\n\n      return combineLatest(collectionListeners);\n    }));\n  }\n  /**\r\n   * Listens for collections inside collections with the same name to an unlimited depth and returns all of it as an array.\r\n   */\n\n\n  listenForCollectionRecursively$(collectionPath, collectionKey, orderKey) {\n    // const collectionRef = getRefFromPath(collectionPath, this.fs.firestore) as CollectionReference<T>;\n    const collectionQuery = new QueryContainer(getRefFromPath(collectionPath, this.fs.firestore));\n\n    if (orderKey != null) {\n      collectionQuery.orderBy(orderKey);\n    }\n\n    return this.listenForCollectionSimple$(collectionQuery.query).pipe(mergeMap(items => {\n      if (items.length <= 0) {\n        return of([]);\n      } // TODO  perhaps make this throw an error so that we can skip it\n      // if (items.length <= 0) { throwError('No more '); }\n\n\n      const nextLevelObs = [];\n\n      for (const item of items) {\n        // const nextLevelPath = item.firestoreMetadata.ref.collection(collectionKey).path;  // one level deeper\n        const nextLevelPath = item.firestoreMetadata.ref.path.concat('/', collectionKey); // one level deeper\n\n        const nextLevelItems$ = this.listenForCollectionRecursively$(nextLevelPath, collectionKey, orderKey).pipe(map(nextLevelItems => {\n          if (nextLevelItems.length > 0) {\n            return Object.assign(Object.assign({}, item), {\n              [collectionKey]: nextLevelItems\n            });\n          } else {\n            return Object.assign({}, item);\n          } // dont include an empty array\n\n        }));\n        nextLevelObs.push(nextLevelItems$);\n      }\n\n      return combineLatest(nextLevelObs).pipe(tap(val => console.log(val)));\n    }));\n  }\n  /* ---------- ADD -------------- */\n\n  /**\r\n   * Add document to firestore and split it up into sub collection.\r\n   *\r\n   * @param data the data to be saved\r\n   * @param collectionRef CollectionReference reference to where on firestore the item should be saved\r\n   * @param subCollectionWriters see documentation for SubCollectionWriter for more details on how these are used\r\n   * @param isAddDates if true 'createdDate' and 'modifiedDate' is added to the data\r\n   * @param docId If a docId is given it will use that specific id when saving the doc, if no docId is given a random id will be used.\r\n   */\n\n\n  add$(data, collectionRef, subCollectionWriters = [], isAddDates = true, docId) {\n    if (Array.isArray(data) && docId && subCollectionWriters.length > 0) {\n      const error = {\n        name: 'firestoreExt/invalid-sub-collection-writers',\n        code: 'unknown',\n        message: 'Cannot have both docId and subCollectionWriters at the same time when data is an array',\n        stack: '',\n        data,\n        subCollectionWriters,\n        docId\n      };\n      throw error;\n    }\n\n    let currentDoc;\n    let subCollections = {};\n    /* if the data is an array and a docId is given the entire array will be saved in a single document with that docId,\r\n    * Each item in the array will be saved as a map with the key being the array index\r\n    * We still want the return value of this function to be as an array non as a map\r\n    */\n\n    if (Array.isArray(data) && docId) {\n      currentDoc = data;\n    } else {\n      const split = this.splitDataIntoCurrentDocAndSubCollections(data, subCollectionWriters);\n      currentDoc = split.currentDoc;\n      subCollections = split.subCollections;\n    }\n\n    return this.addSimple$(currentDoc, collectionRef, isAddDates, docId).pipe(\n    /* Add Sub/sub collections*/\n    mergeMap(currentData => {\n      var _a, _b;\n\n      const subWriters = [];\n\n      for (const [subCollectionKey, subCollectionValue] of Object.entries(subCollections)) {\n        let subSubCollectionWriters; // undefined if no subCollectionWriters\n\n        let subDocId;\n\n        if (subCollectionWriters) {\n          subSubCollectionWriters = (_a = subCollectionWriters.find(subColl => subColl.name === subCollectionKey)) === null || _a === void 0 ? void 0 : _a.subCollections;\n          subDocId = (_b = subCollectionWriters.find(subColl => subColl.name === subCollectionKey)) === null || _b === void 0 ? void 0 : _b.docId;\n        }\n\n        const subCollectionRef = getSubCollection(currentData.firestoreMetadata.ref, subCollectionKey);\n        /* Handle array and object differently\r\n        * For example if array and no docId is given it means we should save each entry as a separate doc.\r\n        * If a docId is given we should save it using that docId under a single doc.\r\n        * If not an array it will always be saved as a single doc, using this.defaultDocId as the default docId if none is given */\n\n        if (Array.isArray(subCollectionValue)) {\n          if (subDocId !== undefined) {\n            /* not undefined so save it as a single doc under that docId */\n\n            /* the pipe only matters for the return subCollectionValue not for writing the data */\n            const subWriter = this.add$(subCollectionValue, subCollectionRef, subSubCollectionWriters, isAddDates, subDocId).pipe(map(item => {\n              // return {[key]: item};\n              return {\n                key: subCollectionKey,\n                value: item\n              };\n              /* key and subCollectionValue as separate k,v properties */\n            }));\n            subWriters.push(subWriter);\n          } else {\n            /* docId is undefined so we save each object in the array separate */\n            subCollectionValue.forEach(arrayValue => {\n              /* the pipe only matters for the return subCollectionValue not for writing the data */\n              const subWriter = this.add$(arrayValue, subCollectionRef, subSubCollectionWriters, isAddDates).pipe(map(item => {\n                // return {[key]: [item]};\n\n                /* key and subCollectionValue as separate k,v properties -- subCollectionValue in an array */\n                return {\n                  key: subCollectionKey,\n                  value: [item]\n                };\n              }));\n              subWriters.push(subWriter);\n            });\n          }\n        } else {\n          /* Not an array so a single Object*/\n          subDocId = subDocId !== undefined ? subDocId : this.defaultDocId;\n          /* the pipe only matters for the return subCollectionValue not for writing the data */\n\n          const subWriter = this.add$(subCollectionValue, subCollectionRef, subSubCollectionWriters, isAddDates, subDocId).pipe(map(item => {\n            // return {[key]: item};\n            return {\n              key: subCollectionKey,\n              value: item\n            };\n            /* key and subCollectionValue as separate k,v properties */\n          }));\n          subWriters.push(subWriter);\n        }\n      }\n      /* end of iteration */\n\n\n      if (subWriters.length > 0) {\n        /* if subWriters.length > 0 it means we need to handle the subWriters */\n\n        /* the pipe only matters for the return value not for writing the data */\n        return combineLatest(subWriters).pipe( // tap(sub => console.log(sub)),\n        // TODO super duper ugly way of joining the data together but I cannot think of a better way..also it doesnt really matter.\n        // TODO The ugliness only relates to how the return object looks after we add, it has no effect on how the object is saved on\n        // TODO firestore.\n        map(docDatas => {\n          const groupedData = {};\n          docDatas.forEach(doc => {\n            const key = doc.key;\n            const value = doc.value;\n            /* if groupedData has the key already it means that the several docs have the same key..so an array */\n            // @ts-ignore\n\n            if (groupedData.hasOwnProperty(key) && Array.isArray(groupedData[key])) {\n              /* groupedData[key] must be an array since it already exist..add this doc.value to the array */\n              // @ts-ignore\n              groupedData[key].push(value[0]);\n            } else {\n              // @ts-ignore\n              groupedData[key] = value;\n            }\n          });\n          return groupedData;\n        }), // tap(groupedData => console.log(groupedData)),\n        map(groupedData => {\n          return Object.assign(Object.assign({}, currentData), groupedData);\n        }));\n      } else {\n        return of(currentData);\n      }\n    })).pipe( // @ts-ignore\n    take(1));\n  }\n  /* ----------  EDIT -------------- */\n\n  /**\r\n   * Update document and child documents\r\n   *\r\n   * Be careful when updating a document of any kind since we allow partial data there cannot be any type checking prior to update\r\n   * so its possible to introduce spelling mistakes on attributes and so forth\r\n   *\r\n   * @param data the data that is to be added or updated { [field: string]: any }\r\n   * @param docRef DocumentReference to be updated\r\n   * @param subCollectionWriters if the data contains properties that should be placed in child collections and documents specify that here\r\n   * @param isAddModifiedDate if true the modifiedDate property is added/updated on the affected documents\r\n   */\n\n\n  update$(data, docRef, subCollectionWriters = [], isAddModifiedDate = true) {\n    if (subCollectionWriters == null || subCollectionWriters.length === 0) {\n      return this.updateSimple$(data, docRef, isAddModifiedDate); // no subCollectionWriters so just do a simple update\n    }\n\n    const batch = this.updateDeepToBatchHelper(data, docRef, subCollectionWriters, isAddModifiedDate);\n    return this.batchCommit$(batch);\n  }\n  /**\r\n   * Update/ add data to the firestore documents\r\n   *\r\n   * @param docRefs list of DocumentReference to be have their data updated\r\n   * @param data data to add/update\r\n   * @param isAddModifiedDate if true the modifiedDate is added/updated\r\n   */\n\n\n  updateMultiple$(docRefs, data, isAddModifiedDate = true) {\n    // const batch = this.fs.firebaseApp.firestore().batch();\n    const batch = writeBatch(this.fs.firestore);\n\n    if (isAddModifiedDate) {\n      data = addModifiedDate(data, false);\n    }\n\n    docRefs.forEach(docRef => {\n      batch.update(docRef, data);\n    });\n    return this.batchCommit$(batch);\n  }\n  /**\r\n   * Firestore doesn't allow you do change the name or move a doc directly so you will have to create a new doc under the new name\r\n   * and then delete the old doc.\r\n   * returns the new doc once the delete is done.\r\n   *\r\n   * @param docRef DocumentReference to have its id changed\r\n   * @param newId the new id\r\n   * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n   * @param subCollectionWriters if the document has child documents the SubCollectionWriters are needed to add them back\r\n   */\n\n\n  changeDocId$(docRef, newId, subCollectionQueries = [], subCollectionWriters) {\n    if (subCollectionWriters == null) {\n      subCollectionWriters = subCollectionQueries;\n    }\n\n    const collectionRef = docRef.parent;\n    return this.listenForDoc$(docRef, subCollectionQueries).pipe( // @ts-ignore\n    take(1), map(oldData => this.cleanExtrasFromData(oldData, subCollectionWriters)), switchMap(oldData => {\n      return this.add$(oldData, collectionRef, subCollectionWriters, false, newId).pipe(\n      /* add the data under id*/\n      mergeMap(newData => {\n        return this.delete$(docRef, subCollectionQueries).pipe(map(() => newData)\n        /* keep the new data */\n        );\n      }));\n    }), catchError(err => {\n      console.log('Failed to Change Doc Id: ' + err);\n      throw err;\n    }), take(1));\n  }\n  /* Move Item in Array */\n\n  /**\r\n   * Moved item within the same list so we need to update the index of all items in the list;\r\n   * Use a copy if you dont wish to update the given array, for example when you want to just listen for the change of the db..\r\n   * The reason to not do this is because it takes some time for the db to update and it looks better if the list updates immediately.\r\n   *\r\n   * @param items array of FireItem<A> docs with index variables to be updated\r\n   * @param fromIndex\r\n   * @param toIndex\r\n   * @param useCopy if true the given array will not be updated\r\n   */\n\n\n  moveItemInArray$(items, fromIndex, toIndex, useCopy = false) {\n    var _a;\n\n    if (fromIndex == null || toIndex == null || fromIndex === toIndex || items.length <= 0) {\n      // we didnt really move anything\n      return of();\n    }\n\n    if (((_a = items[0]) === null || _a === void 0 ? void 0 : _a.firestoreMetadata) == null) {\n      const error = {\n        name: 'firestoreExt/unable-to-change-index-of-non-document',\n        code: 'not-found',\n        message: 'The array does not appear to be a firestore document or FireItem since it lacks firestoreMetadata'\n      };\n      throw error;\n    }\n\n    const batch = this.getBatchFromMoveItemInIndexedDocs(items, fromIndex, toIndex, useCopy);\n    return this.batchCommit$(batch);\n  }\n  /**\r\n   * Does the heavy lifting when it comes to updating multiple docs to change their index.\r\n   * Not called directly.\r\n   *\r\n   * @param items array of FireItem<A> docs with index variables to be updated\r\n   * @param fromIndex\r\n   * @param toIndex\r\n   * @param useCopy if true the given array will not be updated\r\n   * @protected\r\n   */\n\n\n  getBatchFromMoveItemInIndexedDocs(items, fromIndex, toIndex, useCopy = false) {\n    const lowestIndex = Math.min(fromIndex, toIndex);\n    const batch = writeBatch(this.fs.firestore);\n\n    if (fromIndex == null || toIndex == null || fromIndex === toIndex) {\n      // we didnt really move anything\n      return batch;\n    }\n\n    let usedItems;\n\n    if (useCopy) {\n      usedItems = Object.assign([], items);\n    } else {\n      usedItems = items;\n    }\n\n    moveItemInArray(usedItems, fromIndex, toIndex);\n    const listSliceToUpdate = usedItems.slice(lowestIndex);\n    let i = lowestIndex;\n\n    for (const item of listSliceToUpdate) {\n      if (!useCopy) {\n        // this is just so that the given array's index is also updated immediately\n        item.index = i;\n      }\n\n      const ref = getRefFromPath(item.firestoreMetadata.path, this.fs.firestore);\n      batch.update(ref, {\n        index: i\n      });\n      i++;\n    }\n\n    return batch;\n  }\n  /**\r\n   * Use when you wish to delete an indexed document and have the remaining documents update their indices to reflect the change.\r\n   *\r\n   * @param items array of FireItem<A> docs with index variables to be updated\r\n   * @param indexToDelete\r\n   * @param subCollectionQueries\r\n   * @param useCopy\r\n   */\n\n\n  deleteIndexedItemInArray$(items, indexToDelete, subCollectionQueries = [], useCopy = false) {\n    let usedItems;\n\n    if (useCopy) {\n      usedItems = Object.assign([], items);\n    } else {\n      usedItems = items;\n    }\n\n    const itemToDelete = usedItems[indexToDelete]; // get the delete batch that also contains any sub collections of the item\n\n    return this.getDeleteBatch$(itemToDelete.firestoreMetadata.ref, subCollectionQueries).pipe(map(batch => {\n      // sort and remove the item from the usedItems and then add the update index to the batch\n      usedItems.sort(item => item.index); // make sure array is sorted by index\n\n      usedItems.splice(indexToDelete, 1);\n      this.getBatchFromUpdateIndexFromListOfDocs(usedItems, batch);\n      return batch;\n    }), switchMap(batch => this.batchCommit$(batch)));\n  }\n  /**\r\n   * Use when you wish to delete several indexed documents and have the remaining documents update their indices to reflect the change.\r\n   *\r\n   * @param items array of FireItem<A> docs with index variables to be updated\r\n   * @param indicesToDelete\r\n   * @param subCollectionQueries\r\n   * @param useCopy\r\n   */\n\n\n  deleteIndexedItemsInArray$(items, indicesToDelete, subCollectionQueries = [], useCopy = false) {\n    let usedItems;\n\n    if (useCopy) {\n      usedItems = Object.assign([], items);\n    } else {\n      usedItems = items;\n    }\n\n    usedItems.sort(item => item.index); // make sure array is sorted by index\n\n    const itemsToDelete = usedItems.filter((item, i) => {\n      return indicesToDelete.findIndex(_i => _i === i) !== -1;\n    }); // iterate in reverse so as to not change the indices,\n    // the indices to delete must also be sorted\n\n    indicesToDelete.sort();\n\n    for (let i = indicesToDelete.length - 1; i >= 0; i--) {\n      usedItems.splice(indicesToDelete[i], 1);\n    }\n\n    const docRefsObs$ = []; // get the docRefs for items to be deleted including the ones in the subCollections\n\n    itemsToDelete.forEach(itemToDelete => {\n      const obs$ = this.getDocumentReferencesDeep$(itemToDelete.firestoreMetadata.ref, subCollectionQueries).pipe(take(1));\n      docRefsObs$.push(obs$);\n    });\n    return forkJoin(docRefsObs$).pipe(take(1), map(listOfDocRefs => {\n      // concat all the separate docRefs lists into one array of docRefs\n      let docRefs = [];\n      listOfDocRefs.forEach(refs => {\n        docRefs = docRefs.concat(refs);\n      });\n      return docRefs;\n    }), map(docRefs => this.getDeleteMultipleSimpleBatch(docRefs)), map(batch => this.getBatchFromUpdateIndexFromListOfDocs(usedItems, batch)), switchMap(batch => this.batchCommit$(batch)));\n  }\n  /**\r\n   * Run this on collections with a fixed order using an index: number attribute;\r\n   * This will update that index with the index in the collectionData, so it should be sorted by index first.\r\n   * Basically needs to be run after a delete\r\n   *\r\n   * @param items\r\n   * @param batch\r\n   * @protected\r\n   */\n\n\n  getBatchFromUpdateIndexFromListOfDocs(items, batch = writeBatch(this.fs.firestore)) {\n    items.forEach((item, index) => {\n      if (item.index !== index) {\n        item.index = index; // this is just so that the given array's index is also updated immediately\n\n        const ref = getRefFromPath(item.firestoreMetadata.path, this.fs.firestore);\n        batch.update(ref, {\n          index\n        });\n      }\n    });\n    return batch;\n  }\n\n  transferItemInIndexedDocs(previousArray, currentArray, previousIndex, currentIndex, currentArrayName, additionalDataUpdateOnMovedItem, isUpdateModifiedDateOnMovedItem = true, useCopy = false) {\n    const batch = this.getBatchFromTransferItemInIndexedDocs(previousArray, currentArray, previousIndex, currentIndex, currentArrayName, additionalDataUpdateOnMovedItem, isUpdateModifiedDateOnMovedItem, useCopy);\n    return this.batchCommit$(batch);\n  }\n  /* ----------  DELETE -------------- */\n\n  /**\r\n   * Delete Document and child documents\r\n   *\r\n   * @param docRef DocumentReference that is to be deleted\r\n   * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n   */\n\n\n  delete$(docRef, subCollectionQueries = []) {\n    if (subCollectionQueries == null || subCollectionQueries.length === 0) {\n      // not deep so just do a normal doc delete\n      return this.fs.delete(docRef);\n    }\n\n    return this.getDocumentReferencesDeep$(docRef, subCollectionQueries).pipe(switchMap(docRefList => this.deleteMultipleSimple$(docRefList)));\n  }\n  /**\r\n   * Returns WriteBatch that is set to delete Document and child documents of given docRef\r\n   *\r\n   * @param docRef DocumentReference that is to be deleted\r\n   * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n   * @param batch\r\n   */\n\n\n  getDeleteBatch$(docRef, subCollectionQueries = [], batch = writeBatch(this.fs.firestore)) {\n    if (subCollectionQueries == null || subCollectionQueries.length === 0) {\n      // not deep so just do a normal doc delete\n      batch.delete(docRef);\n      return of(batch);\n    }\n\n    return this.getDocumentReferencesDeep$(docRef, subCollectionQueries).pipe(map(docRefs => this.getDeleteMultipleSimpleBatch(docRefs)), take(1));\n  }\n\n  deleteMultipleByPaths$(docPaths) {\n    const docRefs = docPaths.map(path => getRefFromPath(path, this.fs.firestore));\n    return this.deleteMultipleSimple$(docRefs);\n  }\n  /**\r\n   * Delete Documents and child documents\r\n   *\r\n   * @param docRefs - A list of DocumentReference that are to be deleted\r\n   * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n   */\n\n\n  deleteMultiple$(docRefs, subCollectionQueries = []) {\n    if (subCollectionQueries == null || subCollectionQueries.length === 0) {\n      return this.deleteMultipleSimple$(docRefs);\n    }\n\n    const deepDocRefs$ = [];\n    docRefs.forEach(docRef => {\n      const docRefs$ = this.getDocumentReferencesDeep$(docRef, subCollectionQueries);\n      deepDocRefs$.push(docRefs$);\n    });\n    return combineLatest(deepDocRefs$).pipe( // tap(lists => console.log(lists)),\n    map(lists => {\n      let mainDocRefList = [];\n      lists.forEach(list => {\n        mainDocRefList = mainDocRefList.concat(list);\n      });\n      return mainDocRefList;\n    }), // tap(lists => console.log(lists)),\n    switchMap(docRefList => this.deleteMultipleSimple$(docRefList)));\n  }\n  /**\r\n   * Delete all documents and sub collections as specified in subCollectionQueries.\r\n   * Not very efficient and causes a lot of db reads.\r\n   * If possible use the firebase CLI or the console instead when deleting large collections.\r\n   *\r\n   * @param collectionRef\r\n   * @param subCollectionQueries\r\n   */\n\n\n  deleteCollection$(collectionRef, subCollectionQueries = []) {\n    return this.getDocumentReferencesFromCollectionRef$(collectionRef, subCollectionQueries).pipe(switchMap(docRefs => this.deleteMultiple$(docRefs))).pipe(take(1));\n  }\n  /**\r\n   * Delete firestore document by path\r\n   * Convenience method in case we do not have direct access to the AngularFirestoreDocument reference\r\n   *\r\n   * @param docPath A string representing the path of the referenced document (relative to the root of the database).\r\n   * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n   */\n\n\n  deleteDocByPath$(docPath, subCollectionQueries = []) {\n    const docRef = getRefFromPath(docPath, this.fs.firestore);\n    return this.delete$(docRef, subCollectionQueries);\n  }\n  /**\r\n   * Delete document by FirestoreItem\r\n   *\r\n   * Convenience method that works the same as deleteDeep$ but takes a FirestoreItem to be deleted\r\n   *\r\n   * @param item FirestoreItem to be deleted\r\n   * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n   */\n\n\n  deleteItem$(item, subCollectionQueries = []) {\n    const docRefs = this.getDocumentReferencesFromItem(item, subCollectionQueries);\n    return this.deleteMultipleSimple$(docRefs).pipe( // catchError((err) => { // TODO super ugly and I dont know why this error is thrown..still works\n    //   if (err === 'Document Does not exists') { return of(null); }\n    //   else { throw err; }\n    // }),\n    take(1));\n  }\n\n  cleanExtrasFromData(data, subCollectionWriters = [], additionalFieldsToRemove = []) {\n    // const dataToBeCleaned = cloneDeep(data); /* clone data so we dont modify the original */\n    // const dataToBeCleaned = data;\n    if (Array.isArray(data)) {\n      const cleanDatas = [];\n      data.forEach(d => {\n        cleanDatas.push(this.removeDataExtrasRecursiveHelper(d, subCollectionWriters, additionalFieldsToRemove));\n      });\n      return cleanDatas;\n    } else {\n      return this.removeDataExtrasRecursiveHelper(data, subCollectionWriters, additionalFieldsToRemove);\n    }\n  }\n  /* ----------  PROTECTED METHODS -------------- */\n\n  /**\r\n   * Same as AngularFirestoreDocument.snapshotChanges but it adds the properties in FirebaseDbItem\r\n   * and also allows for to choose action to take when document does not exist\r\n   *\r\n   * Important to understand this is will trigger for every change/update on the document we are listening to.\r\n   *\r\n   * @param docRef DocumentReference that will be listened to\r\n   * @param actionIfNotExist Action to take if document does not exist\r\n   */\n\n\n  listenForDocSimple$(docRef, actionIfNotExist = DocNotExistAction.RETURN_ALL_BUT_DATA) {\n    return this.fs.doc(docRef).pipe(tap(snapshot => {\n      if (!snapshot.exists() && actionIfNotExist === DocNotExistAction.THROW_DOC_NOT_FOUND) {\n        const error = {\n          name: 'FirebaseErrorExt',\n          code: 'not-found',\n          message: 'Document not found and actionIfNotExist is set to THROW_DOC_NOT_FOUND',\n          docRef\n        };\n        throw error;\n      }\n    }), filter(snapshot => {\n      return !(snapshot.exists() && actionIfNotExist === DocNotExistAction.FILTER);\n    }), map(snapshot => {\n      console.log(snapshot.exists());\n\n      if (snapshot.exists() || actionIfNotExist === DocNotExistAction.RETURN_ALL_BUT_DATA) {\n        const data = snapshot.data();\n        const firestoreMetadata = {\n          id: snapshot.id,\n          ref: snapshot.ref,\n          path: docRef.path,\n          isExists: snapshot.exists(),\n          snapshotMetadata: snapshot.metadata\n        };\n        return Object.assign(Object.assign({}, data), {\n          firestoreMetadata\n        });\n      } else if (actionIfNotExist === DocNotExistAction.RETURN_NULL) {\n        /* doc doesn't exist */\n        return null;\n      }\n\n      return null;\n    }), map(data => {\n      if (data != null) {\n        return convertTimestampToDate(data);\n      } else {\n        return data;\n      }\n    }));\n  }\n  /**\r\n   * Listens for single collection and returns an array of documents as FireItem<T>[]\r\n   * Used internally, please use listenForCollection$() instead.\r\n   *\r\n   * @param _query the Query which will be listened to\r\n   * @protected\r\n   */\n\n\n  listenForCollectionSimple$(_query) {\n    /**\r\n     * Returns an observable that will emit whenever the ref changes in any way.\r\n     * Also adds the id and ref to the object.\r\n     */\n    return this.fs.collection(_query).pipe(map(snap => {\n      return snap.docs.map(snapshot => {\n        const data = snapshot.data();\n        const id = snapshot.id;\n        const ref = snapshot.ref;\n        const path = ref.path;\n        const snapshotMetadata = snapshot.metadata;\n        const firestoreMetadata = {\n          id,\n          path,\n          ref,\n          snapshotMetadata,\n          isExists: true\n        };\n        return Object.assign(Object.assign({}, data), {\n          firestoreMetadata\n        });\n      });\n    }), map(datas => datas.map(data => {\n      convertTimestampToDate(data);\n      return data;\n    })));\n  }\n  /**\r\n   * Used internally for both listenForDoc and listenForCollection in order to recursively get collections.\r\n   *\r\n   * Please use listenForDoc or listenForCollection.\r\n   *\r\n   * @param item\r\n   * @param subCollectionQueries\r\n   * @protected\r\n   */\n\n\n  listenForCollectionsDeep(item, subCollectionQueries = []) {\n    if (item == null) {\n      return of([item]);\n    }\n\n    if (subCollectionQueries.length <= 0) {\n      return of([item]);\n    }\n\n    const collectionListeners = [];\n    /* Iterate over each sub collection we have given and create collection listeners*/\n\n    subCollectionQueries.forEach(subCollectionQuery => {\n      const queryContainer = new QueryContainer(getSubCollection(item.firestoreMetadata.ref, subCollectionQuery.name));\n\n      if (subCollectionQuery.queryConstraints) {\n        queryContainer.queryConstraints = subCollectionQuery.queryConstraints; // collectionRef = subCollectionQuery.queryFn(collectionRef) as CollectionReference;\n      } // if (subCollectionQuery.queryFn) {\n      //   collectionRef = subCollectionQuery.queryFn(collectionRef) as CollectionReference;\n      // }\n\n\n      const collectionListener = this.listenForCollectionSimple$(queryContainer.query).pipe( // filter(docs => docs.length > 0), // skip empty collections or if the subCollectionQuery doesnt exist\n\n      /* Uncomment to see data on each update */\n      // tap(d => console.log(d)),\n      // filter(docs => docs != null),\n\n      /* Listen For and Add any Potential Sub Docs*/\n      // @ts-ignore // TODO fix this so that I can remove the ts-ignore\n      mergeMap(items => {\n        if (!subCollectionQuery.subCollections) {\n          return of(items);\n        }\n\n        const docListeners = [];\n        items = items.filter(d => d != null); // filter out potential nulls\n\n        items.forEach(subItem => {\n          const subDocAndCollections$ = this.listenForCollectionsDeep(subItem, subCollectionQuery.subCollections);\n          docListeners.push(subDocAndCollections$);\n        });\n\n        if (docListeners.length <= 0) {\n          return of([]);\n        }\n        /* subCollectionQuery is empty or doesnt exist */\n\n\n        return combineLatest(docListeners).pipe();\n      }),\n      /* End of Listening for sub docs */\n\n      /* If docs.length === 1 and the id is defaultDocId or the given docId it means we are in a sub subCollectionQuery\r\n      and we only care about the data. So we remove the array and just make it one object with the\r\n      subCollectionQuery name as key and docs[0] as value */\n      map(items => {\n        const docId = subCollectionQuery.docId !== undefined ? subCollectionQuery.docId : this.defaultDocId;\n\n        if (items.length === 1 && items[0].firestoreMetadata.id === docId) {\n          return {\n            [subCollectionQuery.name]: items[0]\n          };\n        } else {\n          return {\n            [subCollectionQuery.name]: items\n          };\n        }\n      }));\n      collectionListeners.push(collectionListener);\n    });\n    /* Finally return the combined collection listeners*/\n    // @ts-ignore\n\n    return combineLatest(collectionListeners).pipe(map(collectionDatas => {\n      // map((collectionDatas) => {\n      const datasMap = {};\n      collectionDatas.forEach(collectionData => {\n        for (const [collectionName, items] of Object.entries(collectionData)) {\n          datasMap[collectionName] = items;\n        }\n      });\n      return datasMap;\n    }), map(data => {\n      return Object.assign(Object.assign({}, item), data);\n    }));\n  }\n  /**\r\n   * DO NOT CALL THIS METHOD, meant to be used solely by listenForDocAndSubCollections$\r\n   */\n\n\n  listenForDocDeepRecursiveHelper$(docRef, subCollectionQueries = [], actionIfNotExist = DocNotExistAction.RETURN_NULL) {\n    /* Listen for the docFs*/\n    return this.listenForDocSimple$(docRef, actionIfNotExist).pipe(mergeMap(item => {\n      if (item === null) {\n        return of(item);\n      }\n\n      if (subCollectionQueries.length <= 0) {\n        return of(item);\n      }\n\n      return this.listenForCollectionsDeep(item, subCollectionQueries);\n    }));\n  }\n  /**\r\n   * A replacement/extension to the AngularFirestoreCollection.add.\r\n   * Does the same as AngularFirestoreCollection.add but can also add createdDate and modifiedDate and returns\r\n   * the data with the added properties in FirebaseDbItem\r\n   *\r\n   * Used internally\r\n   *\r\n   * @param data the data to be added to the document, cannot contain types firestore won't allow\r\n   * @param collectionRef the CollectionReference where the document should be added\r\n   * @param isAddDates if true adds modifiedDate and createdDate to the data\r\n   * @param id if given the added document will be given this id, otherwise a random unique id will be used.\r\n   */\n\n\n  addSimple$(data, collectionRef, isAddDates = true, id) {\n    // let dataToBeSaved: A = Object.assign({}, data);\n    let res$;\n\n    if (isAddDates) {\n      const date = new Date();\n      data = addCreatedDate(data, false, date);\n      data = addModifiedDate(data, false, date);\n    }\n\n    if (id !== undefined) {\n      const docRef = getDocRefWithId(collectionRef, id);\n      res$ = this.fs.set(docRef, data);\n    } else {\n      res$ = this.fs.add(collectionRef, data);\n    } // if (Array.isArray(data) && isAddDates) {\n    //   data = data.map(item => {\n    //     return {...item, modifiedDate: dataToBeSaved.modifiedDate, createdData: dataToBeSaved.createdData }\n    //   })\n    // }\n\n\n    res$ = res$.pipe( // tap(() => this.snackBar.open('Success', 'Added', {duration: 1000})),\n    // tap(ref => console.log(ref)),\n    // tap(() => console.log(data)),\n    map(ref => {\n      if (id === undefined && ref) {\n        const path = ref.path;\n        const firestoreMetadata = {\n          id: ref.id,\n          path,\n          ref,\n          isExists: true\n        };\n        return Object.assign(Object.assign({}, data), {\n          firestoreMetadata\n        });\n      } else {\n        // if id is defined it means we used docRef.set and ref is undefined\n        const path = collectionRef.path + '/' + id;\n        ref = getRefFromPath(path, this.fs.firestore);\n        const firestoreMetadata = {\n          id: id,\n          ref,\n          path,\n          isExists: true\n        };\n        return Object.assign(Object.assign({}, data), {\n          firestoreMetadata\n        });\n      }\n    }));\n    return res$.pipe(take(1));\n  }\n  /** Used internally for updates that doesn't affect child documents */\n\n\n  updateSimple$(data, docRef, isAddModifiedDate = true) {\n    if (isAddModifiedDate) {\n      data = addModifiedDate(data, false);\n    }\n\n    return this.fs.update(docRef, data);\n  }\n  /**\r\n   * DO NOT CALL THIS METHOD, used by update deep\r\n   */\n\n\n  updateDeepToBatchHelper(data, docRef, subCollectionWriters = [], isAddModifiedDate = true, batch) {\n    var _a, _b;\n\n    if (batch === undefined) {\n      batch = writeBatch(this.fs.firestore);\n    }\n\n    if (isAddModifiedDate) {\n      data = addModifiedDate(data, false);\n    }\n\n    const split = this.splitDataIntoCurrentDocAndSubCollections(data, subCollectionWriters);\n    const currentDoc = split.currentDoc;\n    const subCollections = split.subCollections; // console.log(currentDoc, subCollections);\n\n    batch.update(docRef, currentDoc);\n\n    for (const [subCollectionKey, subDocUpdateValue] of Object.entries(subCollections)) {\n      let subSubCollectionWriters; // undefined if no subCollectionWriters\n\n      let subDocId;\n\n      if (subCollectionWriters) {\n        subSubCollectionWriters = (_a = subCollectionWriters.find(subColl => subColl.name === subCollectionKey)) === null || _a === void 0 ? void 0 : _a.subCollections;\n        subDocId = (_b = subCollectionWriters.find(subColl => subColl.name === subCollectionKey)) === null || _b === void 0 ? void 0 : _b.docId;\n      }\n\n      subDocId = subDocId !== undefined ? subDocId : this.defaultDocId;\n      /* Set default if none given */\n      // const subDocFs = docRef.collection(subCollectionKey).doc(subDocId);\n\n      const subCollection = getSubCollection(docRef, subCollectionKey);\n      const subDocFs = getDocRefWithId(subCollection, subDocId);\n      batch = this.updateDeepToBatchHelper(subDocUpdateValue, subDocFs, subSubCollectionWriters, isAddModifiedDate, batch);\n    }\n\n    return batch;\n  }\n  /**\r\n   * Used mainly for drag and drop scenarios where we drag an item from one list to another and the the docs\r\n   * have an index value and a groupName.\r\n   *\r\n   * @param previousArray\r\n   * @param currentArray\r\n   * @param previousIndex\r\n   * @param currentIndex\r\n   * @param currentArrayName\r\n   * @param additionalDataUpdateOnMovedItem\r\n   * @param isUpdateModifiedDateOnMovedItem\r\n   * @param useCopy\r\n   * @protected\r\n   */\n\n\n  getBatchFromTransferItemInIndexedDocs(previousArray, currentArray, previousIndex, currentIndex, currentArrayName, additionalDataUpdateOnMovedItem, isUpdateModifiedDateOnMovedItem = true, useCopy = false) {\n    let usedPreviousArray;\n    let usedCurrentArray;\n\n    if (useCopy) {\n      usedPreviousArray = Object.assign([], previousArray);\n      usedCurrentArray = Object.assign([], currentArray);\n    } else {\n      usedPreviousArray = previousArray;\n      usedCurrentArray = currentArray;\n    }\n\n    transferArrayItem(usedPreviousArray, usedCurrentArray, previousIndex, currentIndex);\n    const batch = writeBatch(this.fs.firestore);\n\n    if (additionalDataUpdateOnMovedItem !== undefined) {\n      const movedItem = usedCurrentArray[currentIndex];\n      const movedItemRef = movedItem.firestoreMetadata.ref;\n      const data = Object.assign(Object.assign({}, additionalDataUpdateOnMovedItem), {\n        groupName: currentArrayName\n      });\n\n      if (!useCopy) {\n        addDataToItem(movedItem, data, true);\n      }\n\n      if (isUpdateModifiedDateOnMovedItem) {\n        const date = new Date();\n        addModifiedDate(data, true, date);\n\n        if (!useCopy) {\n          addModifiedDate(movedItem, true, date);\n        }\n      }\n\n      batch.update(movedItemRef, data);\n    }\n\n    const currentArraySliceToUpdate = usedCurrentArray.slice(currentIndex);\n    let i = currentIndex;\n\n    for (const item of currentArraySliceToUpdate) {\n      // @ts-ignore\n      batch.update(item.firestoreMetadata.ref, {\n        index: i\n      });\n\n      if (!useCopy) {\n        item.index = i;\n      }\n\n      i++;\n    }\n\n    const prevArraySliceToUpdate = usedPreviousArray.slice(previousIndex);\n    i = previousIndex;\n\n    for (const item of prevArraySliceToUpdate) {\n      // @ts-ignore\n      batch.update(item.firestoreMetadata.ref, {\n        index: i\n      });\n\n      if (!useCopy) {\n        item.index = i;\n      }\n\n      i++;\n    }\n\n    return batch;\n  }\n  /**\r\n   * Delete Documents\r\n   *\r\n   * @param docRefs - A list of DocumentReference that are to be deleted\r\n   */\n\n\n  deleteMultipleSimple$(docRefs) {\n    const batch = this.getDeleteMultipleSimpleBatch(docRefs);\n    return this.batchCommit$(batch);\n  }\n\n  getDeleteMultipleSimpleBatch(docRefs, batch = writeBatch(this.fs.firestore)) {\n    docRefs.forEach(docRef => {\n      batch.delete(docRef);\n    });\n    return batch;\n  }\n  /**\r\n   * Recursive method to clean FirestoreBaseItem properties from the dbItem\r\n   *\r\n   * @param dbItem the data to be cleaned\r\n   * @param subCollectionWriters list of SubCollectionWriters to handle sub collections\r\n   * @param additionalFieldsToRemove\r\n   */\n\n\n  removeDataExtrasRecursiveHelper(dbItem, subCollectionWriters = [], additionalFieldsToRemove = []) {\n    // const extraPropertyNames: string[] = Object.getOwnPropertyNames(new DbItemExtras());\n    const extraPropertyNames = ['firestoreMetadata'].concat(additionalFieldsToRemove);\n    /* Current level delete */\n\n    for (const extraPropertyName of extraPropertyNames) {\n      delete dbItem[extraPropertyName];\n    }\n\n    subCollectionWriters.forEach(col => {\n      if (Array.isArray(dbItem[col.name])) {\n        /* property is array so will contain multiple docs */\n        const docs = dbItem[col.name];\n        docs.forEach((d, i) => {\n          if (col.subCollections) {\n            this.removeDataExtrasRecursiveHelper(d, col.subCollections, additionalFieldsToRemove);\n          } else {\n            /*  */\n            for (const extraPropertyName of extraPropertyNames) {\n              delete dbItem[col.name][i][extraPropertyName];\n            }\n          }\n        });\n      } else {\n        /* not an array so a single doc*/\n        if (col.subCollections) {\n          this.removeDataExtrasRecursiveHelper(dbItem[col.name], col.subCollections, additionalFieldsToRemove);\n        } else {\n          for (const extraPropertyName of extraPropertyNames) {\n            delete dbItem[col.name][extraPropertyName];\n          }\n        }\n      }\n    });\n    return dbItem;\n  }\n  /**\r\n   * Returns an Observable containing a list of DocumentReference found under the given docRef using the SubCollectionQuery[]\r\n   * Mainly used to delete a docFs and its sub docs\r\n   * @param ref: DocumentReference | CollectionReference\r\n   * @param subCollectionQueries: SubCollectionQuery[]\r\n   */\n\n\n  getDocumentReferencesDeep$(ref, subCollectionQueries = []) {\n    if (ref instanceof DocumentReference) {\n      return this.getDocumentReferencesFromDocRef$(ref, subCollectionQueries);\n    } else {\n      // CollectionReference\n      return this.getDocumentReferencesFromCollectionRef$(ref, subCollectionQueries);\n    }\n  }\n\n  getDocumentReferencesFromDocRef$(docRef, subCollectionQueries = []) {\n    return this.listenForDoc$(docRef, subCollectionQueries).pipe(take(1), map(item => this.getPathsFromItemDeepRecursiveHelper(item, subCollectionQueries)), // tap(pathList => console.log(pathList)),\n    map(pathList => {\n      return pathList.map(path => getRefFromPath(path, this.fs.firestore));\n    }));\n  }\n\n  getDocumentReferencesFromCollectionRef$(collectionRef, subCollectionQueries = []) {\n    return this.listenForCollectionSimple$(collectionRef).pipe( // @ts-ignore\n    take(1), mergeMap(items => {\n      let docListeners;\n      docListeners = items.map(item => this.listenForDoc$(item.firestoreMetadata.ref, subCollectionQueries));\n      return combineLatest(docListeners);\n    }), map(items => {\n      let paths = [];\n      items.forEach(item => {\n        paths = paths.concat(this.getPathsFromItemDeepRecursiveHelper(item, subCollectionQueries));\n      });\n      return paths;\n    }), map(pathList => {\n      return pathList.map(path => getRefFromPath(path, this.fs.firestore));\n    }));\n  }\n  /**\r\n   * Used by deleteDeepByItem$ to get all the AngularFirestoreDocuments to be deleted\r\n   * including child documents using SubCollectionQueries\r\n   *\r\n   * Internal use\r\n   * @param item FirestoreItem from where we get the AngularFirestoreDocuments\r\n   * @param subCollectionQueries if the dbItem has child documents the subCollectionQueries are needed to locate them\r\n   */\n\n\n  getDocumentReferencesFromItem(item, subCollectionQueries = []) {\n    const paths = this.getPathsFromItemDeepRecursiveHelper(item, subCollectionQueries);\n    return paths.map(path => getRefFromPath(path, this.fs.firestore));\n  }\n  /**\r\n   * DO NOT CALL THIS METHOD, its meant as a support method for getDocs$\r\n   */\n\n\n  getPathsFromItemDeepRecursiveHelper(item, subCollectionQueries = []) {\n    if (subCollectionQueries == null || subCollectionQueries.length === 0) {\n      return [item.firestoreMetadata.path];\n    }\n\n    let pathList = [];\n    pathList.push(item.firestoreMetadata.path);\n    subCollectionQueries.forEach(col => {\n      if (Array.isArray(item[col.name]) && !col.docId) {\n        /* property is array and not using docId so will contain multiple docs */\n        const items = item[col.name];\n        items.forEach(subItem => {\n          if (col.subCollections) {\n            pathList = pathList.concat(this.getPathsFromItemDeepRecursiveHelper(subItem, col.subCollections));\n          } else {\n            pathList.push(subItem.firestoreMetadata.path);\n          }\n        });\n      } else {\n        /* not an array so a single doc*/\n        if (col.subCollections) {\n          pathList = pathList.concat(this.getPathsFromItemDeepRecursiveHelper(item, col.subCollections));\n        } else {\n          const subItem = item[col.name];\n\n          if (subItem != null && 'path' in subItem.firestoreMetadata) {\n            pathList.push(subItem.firestoreMetadata.path);\n          } // const path = (dbItem[col.name] as FirestoreItem).path;\n\n        }\n      }\n    });\n    return pathList;\n  }\n  /**\r\n   * DO  NOT  CALL THIS METHOD, used in addDeep and updateDeep to split the data into currentDoc and subCollections\r\n   * Only goes one sub level deep;\r\n   */\n\n\n  splitDataIntoCurrentDocAndSubCollections(data, subCollectionWriters = []) {\n    /* Split data into current doc and sub collections */\n    let currentDoc = {};\n    const subCollections = {};\n    /* Check if the key is in subCollections, if it is place it in subCollections else place it in currentDoc */\n    // not array so object\n\n    for (const [key, value] of Object.entries(data)) {\n      // console.log(key, value);\n      if (subCollectionWriters && subCollectionWriters.length > 0) {\n        const subCollectionWriter = subCollectionWriters.find(subColl => subColl.name === key);\n\n        if (subCollectionWriter) {\n          subCollections[key] = value;\n        } else {\n          currentDoc[key] = value;\n        }\n      } else {\n        currentDoc = data;\n      }\n    }\n\n    return {\n      currentDoc,\n      subCollections\n    };\n  }\n  /**\r\n   * Turn a batch into an Observable instead of Promise.\r\n   *\r\n   * For some reason angularfire returns a promise on batch.commit() instead of an observable like for\r\n   * everything else.\r\n   *\r\n   * This method turns it into an observable\r\n   */\n\n\n  batchCommit$(batch) {\n    return from(batch.commit()).pipe(take(1));\n  }\n\n}\n/**\r\n * Firebase version 9 changed the query syntax\r\n * The new syntax broken the ability to chain queries like this:\r\n *\r\n * collectionRef.where('foo', '==', 123).limit(10)..returns the collection ref\r\n *\r\n * now instead you must write it like this, query(collectionRef, where('foo', '==', 123), limit(10))...returns a Query\r\n *\r\n * which is ugly and make you loose the information that was present in the collectionRef since a Query is returned instead,\r\n * which holds less information than a CollectionReference.\r\n *\r\n * This Container is meant to allow you to chain queries, like before version 9 and also retain the information in\r\n * the original CollectionReference\r\n */\n\n\nclass QueryContainer {\n  constructor(ref) {\n    this.ref = ref;\n    this.queryConstraints = [];\n  }\n  /** factory method to create container from path */\n\n\n  static fromPath(firestore, path) {\n    const ref = collection(firestore, path);\n    return new this(ref);\n  }\n  /** Returns the query with all the query constraints */\n\n\n  get query() {\n    return query(this.ref, ...this.queryConstraints);\n  }\n  /** Calls the firebase getDocs() method and listens for the documents in the query. */\n\n\n  getDocs$() {\n    return from(getDocs(this.query));\n  }\n\n  where(fieldPath, opStr, value) {\n    this.queryConstraints.push(where(fieldPath, opStr, value));\n    return this;\n  }\n\n  orderBy(fieldPath, directionStr) {\n    this.queryConstraints.push(orderBy(fieldPath, directionStr));\n    return this;\n  }\n\n  limit(_limit) {\n    this.queryConstraints.push(limit(_limit));\n    return this;\n  }\n\n  limitToLast(_limit) {\n    this.queryConstraints.push(limitToLast(_limit));\n    return this;\n  }\n\n  startAt(snapshot, ...fieldValues) {\n    if (snapshot) {\n      this.queryConstraints.push(startAt(snapshot));\n    } else if (fieldValues) {\n      this.queryConstraints.push(startAt(...fieldValues));\n    }\n\n    return this;\n  }\n\n  startAfter(snapshot, ...fieldValues) {\n    if (snapshot) {\n      this.queryConstraints.push(startAfter(snapshot));\n    } else if (fieldValues) {\n      this.queryConstraints.push(startAfter(...fieldValues));\n    }\n\n    return this;\n  }\n\n  endAt(snapshot, ...fieldValues) {\n    if (snapshot) {\n      this.queryConstraints.push(endAt(snapshot));\n    } else if (fieldValues) {\n      this.queryConstraints.push(endAt(...fieldValues));\n    }\n\n    return this;\n  }\n\n  endBefore(snapshot, ...fieldValues) {\n    if (snapshot) {\n      this.queryConstraints.push(endBefore(snapshot));\n    } else if (fieldValues) {\n      this.queryConstraints.push(endBefore(...fieldValues));\n    }\n\n    return this;\n  }\n\n}\n\nconst nop = () => tap(noop);\n/**\r\n * Takes a key/value object of observables or tuples:\r\n *\r\n * ```\r\n * {\r\n *  obs1: of(123),\r\n *  obs2: [of(\"value\").pipe(delay(1000)), \"startWith value\"],\r\n * }\r\n * ```\r\n *\r\n * and every time one of the source observables emits, emits an object\r\n * with the latest value from all observables:\r\n *\r\n * ```\r\n * {\r\n *  obs1: 123,\r\n *  obs2: \"startWith value\",\r\n * }\r\n * ```\r\n */\n\n\nconst combineLatestToObject = observables => {\n  const keys = Object.keys(observables);\n  return combineLatest(keys.map(k => {\n    const obs = observables[k];\n    return Array.isArray(obs) ? obs[0].pipe(startWith(obs[1])) : obs.pipe(nop());\n  })).pipe(map(b => b.reduce((acc, val, i) => Object.assign(Object.assign({}, acc), {\n    [keys[i]]: val\n  }), {})));\n};\n\nclass FirestoreWrapper {\n  /**\r\n   * Uses firebase/firestore directly\r\n   * Simply makes the returned Promises into Observables\r\n   */\n  constructor(firebaseApp) {\n    this.firebaseApp = firebaseApp;\n  }\n\n  get firestore() {\n    return getFirestore(this.firebaseApp);\n  } // doc\n\n\n  doc(docRef) {\n    return from(getDoc(docRef));\n  }\n\n  add(collectionRef, data) {\n    return from(addDoc(collectionRef, data)).pipe(take(1));\n  }\n\n  set(docRef, data, options) {\n    if (options) {\n      return from(setDoc(docRef, data, options)).pipe(take(1));\n    } else {\n      return from(setDoc(docRef, data)).pipe(take(1));\n    }\n  }\n\n  delete(docRef) {\n    return from(deleteDoc(docRef)).pipe(take(1));\n  }\n\n  update(docRef, data, options) {\n    return from(updateDoc(docRef, data)).pipe(take(1));\n  }\n\n  collection(q) {\n    return from(getDocs(q));\n  }\n\n}\n/**\r\n * FirestoreExt Class that uses the FirestoreWrapper\r\n * Simply extend this class and give it an initialized FirebaseApp to use the FireStoreExtended methods.\r\n */\n\n\nclass FirestoreExt extends FirestoreExtended {\n  constructor(firebaseApp, defaultDocId = 'data') {\n    super(new FirestoreWrapper(firebaseApp), defaultDocId);\n  }\n\n} // import {InjectionToken} from '@angular/core';\n// import {FirebaseApp} from 'firebase/app';\n\n\nclass FirebaseConfig {} // export const FIREBASE_APP = new InjectionToken<FirebaseApp>('firebase_app.config');\n\n\nconst FIRESTORE_USE_EMULATOR = {\n  // useEmulator: false,\n  host: 'localhost',\n  port: 8080\n}; // export type FirestoreEmulatorConfig  = {\n//   useEmulator: boolean;\n//   emulatorHost: string;\n//   emulatorPort: 4200\n// }\n\nclass NgxFirebaseModule {\n  /**\r\n   * To be used as an Angular Module to inject the FirebaseConfig\r\n   * The FirebaseConfig is then used by NgxFirebaseService to create a Firebase app, this contains the websocket connection to firebase.\r\n   * We can then inject NgxRxFireService in to any service that wishes to use the Firebase app connection without creating\r\n   * additional connections.\r\n   * The purpose is simply to make sure that we only create a single Firebase App and a single connection\r\n   */\n  constructor(parentModule) {\n    if (parentModule) {\n      throw new Error('NgxFirestoreExtendedModule is already loaded. Import it in the AppModule only');\n    }\n  }\n\n  static forRoot(config) {\n    return {\n      ngModule: NgxFirebaseModule,\n      providers: [{\n        provide: FirebaseConfig,\n        useValue: config\n      }]\n    };\n  }\n\n}\n\nNgxFirebaseModule.fac = function NgxFirebaseModule_Factory(t) {\n  return new (t || NgxFirebaseModule)(i0.inject(NgxFirebaseModule, 12));\n};\n\nNgxFirebaseModule.mod = /* @__PURE__ */i0.defineNgModule({\n  type: NgxFirebaseModule\n});\nNgxFirebaseModule.inj = /* @__PURE__ */i0.defineInjector({\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.setClassMetadata(NgxFirebaseModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [],\n      imports: [CommonModule]\n    }]\n  }], function () {\n    return [{\n      type: NgxFirebaseModule,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }];\n  }, null);\n})();\n\nclass NgxFirebaseService {\n  constructor(config, emulatorConfig) {\n    this.emulatorConfig = emulatorConfig;\n\n    if (!firebase.getApps().length) {\n      if (config) {\n        this.firebaseApp = initializeApp(config);\n      } else {\n        throw new Error('No previous Firebase App initialized so please provide a FirebaseConfig');\n      }\n    } else {\n      this.firebaseApp = firebase.getApps()[0]; // if already initialized, use that one\n    }\n\n    if (emulatorConfig) {\n      connectFirestoreEmulator(getFirestore(this.firebaseApp), emulatorConfig.host, emulatorConfig.port); // v9\n      // getFirestore(this.firebaseApp).useEmulator(emulatorConfig.host, emulatorConfig.port); // v8\n    }\n  }\n\n}\n\nNgxFirebaseService.fac = function NgxFirebaseService_Factory(t) {\n  return new (t || NgxFirebaseService)(i0.inject(FirebaseConfig, 8), i0.inject(FIRESTORE_USE_EMULATOR, 8));\n};\n\nNgxFirebaseService.prov = /* @__PURE__ */i0.defineInjectable({\n  token: NgxFirebaseService,\n  factory: NgxFirebaseService.fac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.setClassMetadata(NgxFirebaseService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FirebaseConfig,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FIRESTORE_USE_EMULATOR]\n      }]\n    }];\n  }, null);\n})();\n\nclass NgxFirestoreExtendedService {\n  constructor(ngxFirebaseService) {\n    this.ngxFirebaseService = ngxFirebaseService;\n    this.fireExt = new FirestoreExt(ngxFirebaseService.firebaseApp);\n    /* inject Firebase App from NgxFirebaseService */\n  }\n\n  get firebaseApp() {\n    /** Convenience getter */\n    return this.ngxFirebaseService.firebaseApp;\n  }\n\n}\n\nNgxFirestoreExtendedService.fac = function NgxFirestoreExtendedService_Factory(t) {\n  return new (t || NgxFirestoreExtendedService)(i0.inject(NgxFirebaseService));\n};\n\nNgxFirestoreExtendedService.prov = /* @__PURE__ */i0.defineInjectable({\n  token: NgxFirestoreExtendedService,\n  factory: NgxFirestoreExtendedService.fac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.setClassMetadata(NgxFirestoreExtendedService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: NgxFirebaseService\n    }];\n  }, null);\n})();\n/*\r\n * Public API Surface of firestore-extended.ts\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { DocNotExistAction, FIRESTORE_USE_EMULATOR, FirebaseConfig, FirestoreExt, FirestoreExtended, FirestoreWrapper, NgxFirebaseModule, NgxFirebaseService, NgxFirestoreExtendedService, QueryContainer, addCreatedBy, addCreatedDate, addDataToItem, addModifiedDate, combineLatestToObject, convertTimestampToDate, getDocRefWithId, getRefFromPath, getSubCollection };",
  "map": {
    "version": 3,
    "sources": [
      "D:/Programming/web/ng/libraries/firestore-extended/dist/firestore-extended/fesm2015/firestore-extended.mjs"
    ],
    "names": [
      "of",
      "combineLatest",
      "forkJoin",
      "from",
      "noop",
      "map",
      "mergeMap",
      "tap",
      "take",
      "switchMap",
      "catchError",
      "filter",
      "startWith",
      "doc",
      "collection",
      "writeBatch",
      "DocumentReference",
      "query",
      "getDocs",
      "where",
      "orderBy",
      "limit",
      "limitToLast",
      "startAt",
      "startAfter",
      "endAt",
      "endBefore",
      "getFirestore",
      "getDoc",
      "addDoc",
      "setDoc",
      "deleteDoc",
      "updateDoc",
      "connectFirestoreEmulator",
      "i0",
      "NgModule",
      "Optional",
      "SkipSelf",
      "Injectable",
      "Inject",
      "CommonModule",
      "firebase",
      "initializeApp",
      "getRefFromPath",
      "path",
      "firestore",
      "pathSegmentAmount",
      "split",
      "length",
      "getSubCollection",
      "docRef",
      "collectionName",
      "collectionPath",
      "concat",
      "getDocRefWithId",
      "collectionRef",
      "id",
      "addDataToItem",
      "item",
      "dataToAdd",
      "inplace",
      "Object",
      "entries",
      "forEach",
      "k",
      "v",
      "assign",
      "addCreatedDate",
      "createdDate",
      "Date",
      "addModifiedDate",
      "modifiedDate",
      "addCreatedBy",
      "createdBy",
      "convertTimestampToDate",
      "hasOwnProperty",
      "toDate",
      "moveItemInArray",
      "array",
      "fromIndex",
      "toIndex",
      "clamp",
      "to",
      "target",
      "delta",
      "i",
      "transferArrayItem",
      "currentArray",
      "targetArray",
      "currentIndex",
      "targetIndex",
      "splice",
      "copyArrayItem",
      "value",
      "max",
      "Math",
      "min",
      "DocNotExistAction",
      "FirestoreExtended",
      "constructor",
      "fs",
      "defaultDocId",
      "listenForDoc$",
      "subCollectionQueries",
      "actionIfNotExist",
      "RETURN_ALL_BUT_DATA",
      "listenForDocDeepRecursiveHelper$",
      "pipe",
      "data",
      "listenForCollection$",
      "_query",
      "listenForCollectionSimple$",
      "items",
      "collectionListeners",
      "collectionListener",
      "listenForCollectionsDeep",
      "push",
      "listenForCollectionRecursively$",
      "collectionKey",
      "orderKey",
      "collectionQuery",
      "QueryContainer",
      "nextLevelObs",
      "nextLevelPath",
      "firestoreMetadata",
      "ref",
      "nextLevelItems$",
      "nextLevelItems",
      "val",
      "console",
      "log",
      "add$",
      "subCollectionWriters",
      "isAddDates",
      "docId",
      "Array",
      "isArray",
      "error",
      "name",
      "code",
      "message",
      "stack",
      "currentDoc",
      "subCollections",
      "splitDataIntoCurrentDocAndSubCollections",
      "addSimple$",
      "currentData",
      "_a",
      "_b",
      "subWriters",
      "subCollectionKey",
      "subCollectionValue",
      "subSubCollectionWriters",
      "subDocId",
      "find",
      "subColl",
      "subCollectionRef",
      "undefined",
      "subWriter",
      "key",
      "arrayValue",
      "docDatas",
      "groupedData",
      "update$",
      "isAddModifiedDate",
      "updateSimple$",
      "batch",
      "updateDeepToBatchHelper",
      "batchCommit$",
      "updateMultiple$",
      "docRefs",
      "update",
      "changeDocId$",
      "newId",
      "parent",
      "oldData",
      "cleanExtrasFromData",
      "newData",
      "delete$",
      "err",
      "moveItemInArray$",
      "useCopy",
      "getBatchFromMoveItemInIndexedDocs",
      "lowestIndex",
      "usedItems",
      "listSliceToUpdate",
      "slice",
      "index",
      "deleteIndexedItemInArray$",
      "indexToDelete",
      "itemToDelete",
      "getDeleteBatch$",
      "sort",
      "getBatchFromUpdateIndexFromListOfDocs",
      "deleteIndexedItemsInArray$",
      "indicesToDelete",
      "itemsToDelete",
      "findIndex",
      "_i",
      "docRefsObs$",
      "obs$",
      "getDocumentReferencesDeep$",
      "listOfDocRefs",
      "refs",
      "getDeleteMultipleSimpleBatch",
      "transferItemInIndexedDocs",
      "previousArray",
      "previousIndex",
      "currentArrayName",
      "additionalDataUpdateOnMovedItem",
      "isUpdateModifiedDateOnMovedItem",
      "getBatchFromTransferItemInIndexedDocs",
      "delete",
      "docRefList",
      "deleteMultipleSimple$",
      "deleteMultipleByPaths$",
      "docPaths",
      "deleteMultiple$",
      "deepDocRefs$",
      "docRefs$",
      "lists",
      "mainDocRefList",
      "list",
      "deleteCollection$",
      "getDocumentReferencesFromCollectionRef$",
      "deleteDocByPath$",
      "docPath",
      "deleteItem$",
      "getDocumentReferencesFromItem",
      "additionalFieldsToRemove",
      "cleanDatas",
      "d",
      "removeDataExtrasRecursiveHelper",
      "listenForDocSimple$",
      "snapshot",
      "exists",
      "THROW_DOC_NOT_FOUND",
      "FILTER",
      "isExists",
      "snapshotMetadata",
      "metadata",
      "RETURN_NULL",
      "snap",
      "docs",
      "datas",
      "subCollectionQuery",
      "queryContainer",
      "queryConstraints",
      "docListeners",
      "subItem",
      "subDocAndCollections$",
      "collectionDatas",
      "datasMap",
      "collectionData",
      "res$",
      "date",
      "set",
      "add",
      "subDocUpdateValue",
      "subCollection",
      "subDocFs",
      "usedPreviousArray",
      "usedCurrentArray",
      "movedItem",
      "movedItemRef",
      "groupName",
      "currentArraySliceToUpdate",
      "prevArraySliceToUpdate",
      "dbItem",
      "extraPropertyNames",
      "extraPropertyName",
      "col",
      "getDocumentReferencesFromDocRef$",
      "getPathsFromItemDeepRecursiveHelper",
      "pathList",
      "paths",
      "subCollectionWriter",
      "commit",
      "fromPath",
      "getDocs$",
      "fieldPath",
      "opStr",
      "directionStr",
      "_limit",
      "fieldValues",
      "nop",
      "combineLatestToObject",
      "observables",
      "keys",
      "obs",
      "b",
      "reduce",
      "acc",
      "FirestoreWrapper",
      "firebaseApp",
      "options",
      "q",
      "FirestoreExt",
      "FirebaseConfig",
      "FIRESTORE_USE_EMULATOR",
      "host",
      "port",
      "NgxFirebaseModule",
      "parentModule",
      "Error",
      "forRoot",
      "config",
      "ngModule",
      "providers",
      "provide",
      "useValue",
      "fac",
      "mod",
      "inj",
      "type",
      "args",
      "declarations",
      "imports",
      "decorators",
      "NgxFirebaseService",
      "emulatorConfig",
      "getApps",
      "prov",
      "providedIn",
      "NgxFirestoreExtendedService",
      "ngxFirebaseService",
      "fireExt"
    ],
    "mappings": "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",
    "sourcesContent": [
      "import { of, combineLatest, forkJoin, from, noop } from 'rxjs';\nimport { map, mergeMap, tap, take, switchMap, catchError, filter, startWith } from 'rxjs/operators';\nimport { doc, collection, writeBatch, DocumentReference, query, getDocs, where, orderBy, limit, limitToLast, startAt, startAfter, endAt, endBefore, getFirestore, getDoc, addDoc, setDoc, deleteDoc, updateDoc, connectFirestoreEmulator } from 'firebase/firestore';\nimport * as i0 from '@angular/core';\nimport { NgModule, Optional, SkipSelf, Injectable, Inject } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport firebase, { initializeApp } from 'firebase/app';\n\n/** Helper method to get reference from path, the path can be either to a Document or Collection */\r\nfunction getRefFromPath(path, firestore) {\r\n    const pathSegmentAmount = path.split('/').length;\r\n    if (pathSegmentAmount % 2 === 0) { // even number means doc\r\n        return doc(firestore, path);\r\n    }\r\n    else { // odd meaning collection\r\n        return collection(firestore, path);\r\n    }\r\n}\r\nfunction getSubCollection(docRef, collectionName) {\r\n    const collectionPath = docRef.path.concat('/', collectionName);\r\n    return collection(docRef.firestore, collectionPath);\r\n}\r\nfunction getDocRefWithId(collectionRef, id) {\r\n    return doc(collectionRef.firestore, collectionRef.path, id);\r\n}\r\n/**\r\n * Add data to object inplace\r\n * @param item item to add to\r\n * @param dataToAdd data to add\r\n * @param inplace if true the data is added inplace, if false a copy is used\r\n */\r\nfunction addDataToItem(item, dataToAdd, inplace = false) {\r\n    if (inplace) {\r\n        Object.entries(dataToAdd).forEach(([k, v]) => {\r\n            item[k] = v;\r\n        });\r\n        return item;\r\n    }\r\n    else {\r\n        return Object.assign(Object.assign({}, item), dataToAdd);\r\n    }\r\n}\r\n/**\r\n * Add createdDate to the object inplace, if createdDate already exists then we do not overwrite it\r\n *\r\n * @param item item where the createdData will be added\r\n * @param createdDate optional, will use new Date() if none given\r\n * @param inplace if true the data is added inplace, if false a copy is used\r\n */\r\nfunction addCreatedDate(item, inplace = false, createdDate = new Date()) {\r\n    // do not overwrite previous createdDate\r\n    if ('createdDate' in item) {\r\n        return item;\r\n    }\r\n    return addDataToItem(item, { createdDate }, inplace);\r\n}\r\n/**\r\n * Add modifiedDate to the object\r\n *\r\n * @param item item where the modifiedDate will be added\r\n * @param modifiedDate optional, will use new Date() if none given\r\n * @param inplace if true the data is added inplace, if false a copy is used\r\n */\r\nfunction addModifiedDate(item, inplace = false, modifiedDate = new Date()) {\r\n    return addDataToItem(item, { modifiedDate }, inplace);\r\n}\r\n/**\r\n * Add createdBy to the object inplace\r\n *\r\n * @param item item to add to\r\n * @param createdBy profile, user or any type of data\r\n * @param inplace if true the data is added inplace, if false a copy is used\r\n */\r\nfunction addCreatedBy(item, createdBy, inplace = false) {\r\n    return addDataToItem(item, { createdBy }, inplace);\r\n}\r\n/**\r\n * Firestore saves time as timestamps and javascript uses Date objects.\r\n * This functions helps convert the createdDate and modifiedDate from timestamp\r\n * to Date()\r\n *\r\n * inplace\r\n *\r\n * @param item item that contains 'createdDate' and/or 'modifiedDate'\r\n */\r\nfunction convertTimestampToDate(item) {\r\n    if (item.hasOwnProperty('createdDate')) {\r\n        item.createdDate = item.createdDate;\r\n        item.createdDate = item.createdDate.toDate();\r\n    }\r\n    if (item.hasOwnProperty('modifiedDate')) {\r\n        item.modifiedDate = item.modifiedDate;\r\n        item.modifiedDate = item.modifiedDate.toDate();\r\n    }\r\n    return item;\r\n}\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Moves an item one index in an array to another.\r\n * @param array Array in which to move the item.\r\n * @param fromIndex Starting index of the item.\r\n * @param toIndex Index to which the item should be moved.\r\n */\r\nfunction moveItemInArray(array, fromIndex, toIndex) {\r\n    const from = clamp(fromIndex, array.length - 1);\r\n    const to = clamp(toIndex, array.length - 1);\r\n    if (from === to) {\r\n        return;\r\n    }\r\n    const target = array[from];\r\n    const delta = to < from ? -1 : 1;\r\n    for (let i = from; i !== to; i += delta) {\r\n        array[i] = array[i + delta];\r\n    }\r\n    array[to] = target;\r\n}\r\n/**\r\n * Moves an item from one array to another.\r\n * @param currentArray Array from which to transfer the item.\r\n * @param targetArray Array into which to put the item.\r\n * @param currentIndex Index of the item in its current array.\r\n * @param targetIndex Index at which to insert the item.\r\n */\r\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\r\n    const from = clamp(currentIndex, currentArray.length - 1);\r\n    const to = clamp(targetIndex, targetArray.length);\r\n    if (currentArray.length) {\r\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\r\n    }\r\n}\r\n/**\r\n * Copies an item from one array to another, leaving it in its\r\n * original position in current array.\r\n * @param currentArray Array from which to copy the item.\r\n * @param targetArray Array into which is copy the item.\r\n * @param currentIndex Index of the item in its current array.\r\n * @param targetIndex Index at which to insert the item.\r\n *\r\n */\r\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\r\n    const to = clamp(targetIndex, targetArray.length);\r\n    if (currentArray.length) {\r\n        targetArray.splice(to, 0, currentArray[currentIndex]);\r\n    }\r\n}\r\n/** Clamps a number between zero and a maximum. */\r\nfunction clamp(value, max) {\r\n    return Math.max(0, Math.min(max, value));\r\n}\n\n/**\r\n * Action to be taken by listener if the document does not exist.\r\n */\r\nvar DocNotExistAction;\r\n(function (DocNotExistAction) {\r\n    /** returns a null object */\r\n    DocNotExistAction[DocNotExistAction[\"RETURN_NULL\"] = 0] = \"RETURN_NULL\";\r\n    /** return all the extras such as ref, path and so on but no data, kinda just ignores that the doc isn't there */\r\n    DocNotExistAction[DocNotExistAction[\"RETURN_ALL_BUT_DATA\"] = 1] = \"RETURN_ALL_BUT_DATA\";\r\n    /** do not return at all until it does exist */\r\n    DocNotExistAction[DocNotExistAction[\"FILTER\"] = 2] = \"FILTER\";\r\n    /** return doc not found error 'doc_not_found' */\r\n    DocNotExistAction[DocNotExistAction[\"THROW_DOC_NOT_FOUND\"] = 3] = \"THROW_DOC_NOT_FOUND\";\r\n})(DocNotExistAction || (DocNotExistAction = {}));\r\n/**\r\n * Main Class.\r\n *\r\n *\r\n *\r\n */\r\nclass FirestoreExtended {\r\n    /**\r\n     * Constructor for AngularFirestoreWrapper\r\n     *\r\n     * @param fs Firestore wrapper Firestore extended can be used by many Firestore implementations\r\n     * @param defaultDocId The default name given to a subCollection document when no name is given\r\n     */\r\n    constructor(fs, defaultDocId = 'data') {\r\n        this.fs = fs;\r\n        this.defaultDocId = defaultDocId;\r\n    }\r\n    /* ----------  LISTEN -------------- */\r\n    /**\r\n     *\r\n     * Allows for listening to documents and collections n deep up to the firestore max of 100 levels.\r\n     *\r\n     * Triggers for any change in any document that is listened to.\r\n     *\r\n     *\r\n     * E.x:\r\n     *      const subCollectionQueries: SubCollectionQuery[] = [\r\n     *         { name: 'data' },\r\n     *         { name: 'secure' },\r\n     *         { name: 'variants' },\r\n     *         { name: 'images',\r\n     *           queryFn: ref => ref.orderBy('index'),\r\n     *           collectionWithNames: [\r\n     *             { name: 'secure'}\r\n     *           ]\r\n     *         },\r\n     *     ];\r\n     *\r\n     *     this.listenForDocAndSubCollections<Product>(docFs, collections)\r\n     *\r\n     * Wrapper for listenForDocDeepRecursiveHelper$ so that we can cast the return to the correct type\r\n     * All logic is in listenForDocDeepRecursiveHelper$.\r\n     *\r\n     * @param docRef - a docRef with potential queryFn\r\n     * @param subCollectionQueries - see example\r\n     * @param actionIfNotExist Action to take if document does not exist\r\n     */\r\n    listenForDoc$(docRef, subCollectionQueries = [], actionIfNotExist = DocNotExistAction.RETURN_ALL_BUT_DATA) {\r\n        return this.listenForDocDeepRecursiveHelper$(docRef, subCollectionQueries, actionIfNotExist).pipe(map(data => data));\r\n    }\r\n    /**\r\n     * Same as AngularFirestoreCollection.snapshotChanges but it adds the properties in FirebaseDbItem.\r\n     *\r\n     * Important to understand this is will trigger for every change/update on any of the documents we are listening to.\r\n     * That means that if any document we are listening to is changed the entire object will be triggered containing the updated data.\r\n     *\r\n     *\r\n     *    Example usage.\r\n     *\r\n     *    ngFirestoreDeep: RxFirestoreExtended;  //  RxFirestoreExtended variable\r\n     *    restaurantCollectionFs = this.ngFireStore.collection('restaurants'); // AngularFirestoreCollectionRef to restaurants\r\n     *\r\n     *    constructor(private ngFireStore: AngularFirestore) {\r\n     *        this.ngFirestoreDeep = new RxFirestoreExtended(ngFireStore);  //  initialize AngularFireStoreDeep with AngularFirestore\r\n     *    }\r\n     *\r\n     *    listenForRestaurants$(): Observable<RestaurantItem[]> {\r\n     *        return this.ngFirestoreDeep.listenForCollection$<RestaurantItem>(this.restaurantCollectionFs);\r\n     *    }\r\n     *\r\n     *    If you do not wish to listen for changes and only care about getting the values once\r\n     *\r\n     *    getRestaurants$(): Observable<RestaurantItem[]> {\r\n     *        return this.ngFirestoreDeep.listenForCollection$<RestaurantItem>(this.restaurantCollectionFs).pipe(\r\n     *          take(1)\r\n     *        );\r\n     *    }\r\n     *\r\n     * @param _query the collectionRef which will be listened to\r\n     * @param subCollectionQueries\r\n     * @param documentChangeTypes list of DocumentChangeType that will be listened to, if null listen to all\r\n     */\r\n    listenForCollection$(_query, subCollectionQueries = []) {\r\n        /**\r\n         * Returns an observable that will emit whenever the ref changes in any way.\r\n         * Also adds the id and ref to the object.\r\n         */\r\n        return this.listenForCollectionSimple$(_query).pipe(mergeMap((items) => {\r\n            if (items == null || items.length === 0) {\r\n                return of([]);\r\n            }\r\n            if (subCollectionQueries.length <= 0) {\r\n                return of(items);\r\n            }\r\n            const collectionListeners = [];\r\n            items.forEach(item => {\r\n                const collectionListener = this.listenForCollectionsDeep(item, subCollectionQueries);\r\n                collectionListeners.push(collectionListener);\r\n            });\r\n            /* Finally return the combined collection listeners */\r\n            return combineLatest(collectionListeners);\r\n        }));\r\n    }\r\n    /**\r\n     * Listens for collections inside collections with the same name to an unlimited depth and returns all of it as an array.\r\n     */\r\n    listenForCollectionRecursively$(collectionPath, collectionKey, orderKey) {\r\n        // const collectionRef = getRefFromPath(collectionPath, this.fs.firestore) as CollectionReference<T>;\r\n        const collectionQuery = new QueryContainer(getRefFromPath(collectionPath, this.fs.firestore));\r\n        if (orderKey != null) {\r\n            collectionQuery.orderBy(orderKey);\r\n        }\r\n        return this.listenForCollectionSimple$(collectionQuery.query).pipe(mergeMap((items) => {\r\n            if (items.length <= 0) {\r\n                return of([]);\r\n            } // TODO  perhaps make this throw an error so that we can skip it\r\n            // if (items.length <= 0) { throwError('No more '); }\r\n            const nextLevelObs = [];\r\n            for (const item of items) {\r\n                // const nextLevelPath = item.firestoreMetadata.ref.collection(collectionKey).path;  // one level deeper\r\n                const nextLevelPath = item.firestoreMetadata.ref.path.concat('/', collectionKey); // one level deeper\r\n                const nextLevelItems$ = this.listenForCollectionRecursively$(nextLevelPath, collectionKey, orderKey).pipe(map((nextLevelItems) => {\r\n                    if (nextLevelItems.length > 0) {\r\n                        return Object.assign(Object.assign({}, item), { [collectionKey]: nextLevelItems });\r\n                    }\r\n                    else {\r\n                        return Object.assign({}, item);\r\n                    } // dont include an empty array\r\n                }));\r\n                nextLevelObs.push(nextLevelItems$);\r\n            }\r\n            return combineLatest(nextLevelObs).pipe(tap(val => console.log(val)));\r\n        }));\r\n    }\r\n    /* ---------- ADD -------------- */\r\n    /**\r\n     * Add document to firestore and split it up into sub collection.\r\n     *\r\n     * @param data the data to be saved\r\n     * @param collectionRef CollectionReference reference to where on firestore the item should be saved\r\n     * @param subCollectionWriters see documentation for SubCollectionWriter for more details on how these are used\r\n     * @param isAddDates if true 'createdDate' and 'modifiedDate' is added to the data\r\n     * @param docId If a docId is given it will use that specific id when saving the doc, if no docId is given a random id will be used.\r\n     */\r\n    add$(data, collectionRef, subCollectionWriters = [], isAddDates = true, docId) {\r\n        if (Array.isArray(data) && docId && subCollectionWriters.length > 0) {\r\n            const error = {\r\n                name: 'firestoreExt/invalid-sub-collection-writers',\r\n                code: 'unknown',\r\n                message: 'Cannot have both docId and subCollectionWriters at the same time when data is an array',\r\n                stack: '',\r\n                data,\r\n                subCollectionWriters,\r\n                docId\r\n            };\r\n            throw error;\r\n        }\r\n        let currentDoc;\r\n        let subCollections = {};\r\n        /* if the data is an array and a docId is given the entire array will be saved in a single document with that docId,\r\n        * Each item in the array will be saved as a map with the key being the array index\r\n        * We still want the return value of this function to be as an array non as a map\r\n        */\r\n        if (Array.isArray(data) && docId) {\r\n            currentDoc = data;\r\n        }\r\n        else {\r\n            const split = this.splitDataIntoCurrentDocAndSubCollections(data, subCollectionWriters);\r\n            currentDoc = split.currentDoc;\r\n            subCollections = split.subCollections;\r\n        }\r\n        return this.addSimple$(currentDoc, collectionRef, isAddDates, docId).pipe(\r\n        /* Add Sub/sub collections*/\r\n        mergeMap((currentData) => {\r\n            var _a, _b;\r\n            const subWriters = [];\r\n            for (const [subCollectionKey, subCollectionValue] of Object.entries(subCollections)) {\r\n                let subSubCollectionWriters; // undefined if no subCollectionWriters\r\n                let subDocId;\r\n                if (subCollectionWriters) {\r\n                    subSubCollectionWriters = (_a = subCollectionWriters.find(subColl => subColl.name === subCollectionKey)) === null || _a === void 0 ? void 0 : _a.subCollections;\r\n                    subDocId = (_b = subCollectionWriters.find(subColl => subColl.name === subCollectionKey)) === null || _b === void 0 ? void 0 : _b.docId;\r\n                }\r\n                const subCollectionRef = getSubCollection(currentData.firestoreMetadata.ref, subCollectionKey);\r\n                /* Handle array and object differently\r\n                * For example if array and no docId is given it means we should save each entry as a separate doc.\r\n                * If a docId is given we should save it using that docId under a single doc.\r\n                * If not an array it will always be saved as a single doc, using this.defaultDocId as the default docId if none is given */\r\n                if (Array.isArray(subCollectionValue)) {\r\n                    if (subDocId !== undefined) { /* not undefined so save it as a single doc under that docId */\r\n                        /* the pipe only matters for the return subCollectionValue not for writing the data */\r\n                        const subWriter = this.add$(subCollectionValue, subCollectionRef, subSubCollectionWriters, isAddDates, subDocId).pipe(map(item => {\r\n                            // return {[key]: item};\r\n                            return { key: subCollectionKey, value: item }; /* key and subCollectionValue as separate k,v properties */\r\n                        }));\r\n                        subWriters.push(subWriter);\r\n                    }\r\n                    else { /* docId is undefined so we save each object in the array separate */\r\n                        subCollectionValue.forEach((arrayValue) => {\r\n                            /* the pipe only matters for the return subCollectionValue not for writing the data */\r\n                            const subWriter = this.add$(arrayValue, subCollectionRef, subSubCollectionWriters, isAddDates).pipe(map(item => {\r\n                                // return {[key]: [item]};\r\n                                /* key and subCollectionValue as separate k,v properties -- subCollectionValue in an array */\r\n                                return { key: subCollectionKey, value: [item] };\r\n                            }));\r\n                            subWriters.push(subWriter);\r\n                        });\r\n                    }\r\n                }\r\n                else { /* Not an array so a single Object*/\r\n                    subDocId = subDocId !== undefined ? subDocId : this.defaultDocId;\r\n                    /* the pipe only matters for the return subCollectionValue not for writing the data */\r\n                    const subWriter = this.add$(subCollectionValue, subCollectionRef, subSubCollectionWriters, isAddDates, subDocId).pipe(map(item => {\r\n                        // return {[key]: item};\r\n                        return { key: subCollectionKey, value: item }; /* key and subCollectionValue as separate k,v properties */\r\n                    }));\r\n                    subWriters.push(subWriter);\r\n                }\r\n            } /* end of iteration */\r\n            if (subWriters.length > 0) { /* if subWriters.length > 0 it means we need to handle the subWriters */\r\n                /* the pipe only matters for the return value not for writing the data */\r\n                return combineLatest(subWriters).pipe(\r\n                // tap(sub => console.log(sub)),\r\n                // TODO super duper ugly way of joining the data together but I cannot think of a better way..also it doesnt really matter.\r\n                // TODO The ugliness only relates to how the return object looks after we add, it has no effect on how the object is saved on\r\n                // TODO firestore.\r\n                map((docDatas) => {\r\n                    const groupedData = {};\r\n                    docDatas.forEach((doc) => {\r\n                        const key = doc.key;\r\n                        const value = doc.value;\r\n                        /* if groupedData has the key already it means that the several docs have the same key..so an array */\r\n                        // @ts-ignore\r\n                        if (groupedData.hasOwnProperty(key) && Array.isArray(groupedData[key])) {\r\n                            /* groupedData[key] must be an array since it already exist..add this doc.value to the array */\r\n                            // @ts-ignore\r\n                            groupedData[key].push(value[0]);\r\n                        }\r\n                        else {\r\n                            // @ts-ignore\r\n                            groupedData[key] = value;\r\n                        }\r\n                    });\r\n                    return groupedData;\r\n                }), \r\n                // tap(groupedData => console.log(groupedData)),\r\n                map((groupedData) => {\r\n                    return Object.assign(Object.assign({}, currentData), groupedData);\r\n                }));\r\n            }\r\n            else {\r\n                return of(currentData);\r\n            }\r\n        })).pipe(\r\n        // @ts-ignore\r\n        take(1));\r\n    }\r\n    /* ----------  EDIT -------------- */\r\n    /**\r\n     * Update document and child documents\r\n     *\r\n     * Be careful when updating a document of any kind since we allow partial data there cannot be any type checking prior to update\r\n     * so its possible to introduce spelling mistakes on attributes and so forth\r\n     *\r\n     * @param data the data that is to be added or updated { [field: string]: any }\r\n     * @param docRef DocumentReference to be updated\r\n     * @param subCollectionWriters if the data contains properties that should be placed in child collections and documents specify that here\r\n     * @param isAddModifiedDate if true the modifiedDate property is added/updated on the affected documents\r\n     */\r\n    update$(data, docRef, subCollectionWriters = [], isAddModifiedDate = true) {\r\n        if (subCollectionWriters == null || subCollectionWriters.length === 0) {\r\n            return this.updateSimple$(data, docRef, isAddModifiedDate); // no subCollectionWriters so just do a simple update\r\n        }\r\n        const batch = this.updateDeepToBatchHelper(data, docRef, subCollectionWriters, isAddModifiedDate);\r\n        return this.batchCommit$(batch);\r\n    }\r\n    /**\r\n     * Update/ add data to the firestore documents\r\n     *\r\n     * @param docRefs list of DocumentReference to be have their data updated\r\n     * @param data data to add/update\r\n     * @param isAddModifiedDate if true the modifiedDate is added/updated\r\n     */\r\n    updateMultiple$(docRefs, data, isAddModifiedDate = true) {\r\n        // const batch = this.fs.firebaseApp.firestore().batch();\r\n        const batch = writeBatch(this.fs.firestore);\r\n        if (isAddModifiedDate) {\r\n            data = addModifiedDate(data, false);\r\n        }\r\n        docRefs.forEach((docRef) => {\r\n            batch.update(docRef, data);\r\n        });\r\n        return this.batchCommit$(batch);\r\n    }\r\n    /**\r\n     * Firestore doesn't allow you do change the name or move a doc directly so you will have to create a new doc under the new name\r\n     * and then delete the old doc.\r\n     * returns the new doc once the delete is done.\r\n     *\r\n     * @param docRef DocumentReference to have its id changed\r\n     * @param newId the new id\r\n     * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n     * @param subCollectionWriters if the document has child documents the SubCollectionWriters are needed to add them back\r\n     */\r\n    changeDocId$(docRef, newId, subCollectionQueries = [], subCollectionWriters) {\r\n        if (subCollectionWriters == null) {\r\n            subCollectionWriters = subCollectionQueries;\r\n        }\r\n        const collectionRef = docRef.parent;\r\n        return this.listenForDoc$(docRef, subCollectionQueries).pipe(\r\n        // @ts-ignore\r\n        take(1), map((oldData) => this.cleanExtrasFromData(oldData, subCollectionWriters)), switchMap((oldData) => {\r\n            return this.add$(oldData, collectionRef, subCollectionWriters, false, newId).pipe(/* add the data under id*/ mergeMap(newData => {\r\n                return this.delete$(docRef, subCollectionQueries).pipe(map(() => newData) /* keep the new data */);\r\n            }));\r\n        }), catchError(err => {\r\n            console.log('Failed to Change Doc Id: ' + err);\r\n            throw err;\r\n        }), take(1));\r\n    }\r\n    /* Move Item in Array */\r\n    /**\r\n     * Moved item within the same list so we need to update the index of all items in the list;\r\n     * Use a copy if you dont wish to update the given array, for example when you want to just listen for the change of the db..\r\n     * The reason to not do this is because it takes some time for the db to update and it looks better if the list updates immediately.\r\n     *\r\n     * @param items array of FireItem<A> docs with index variables to be updated\r\n     * @param fromIndex\r\n     * @param toIndex\r\n     * @param useCopy if true the given array will not be updated\r\n     */\r\n    moveItemInArray$(items, fromIndex, toIndex, useCopy = false) {\r\n        var _a;\r\n        if (fromIndex == null || toIndex == null || fromIndex === toIndex || items.length <= 0) { // we didnt really move anything\r\n            return of();\r\n        }\r\n        if (((_a = items[0]) === null || _a === void 0 ? void 0 : _a.firestoreMetadata) == null) {\r\n            const error = {\r\n                name: 'firestoreExt/unable-to-change-index-of-non-document',\r\n                code: 'not-found',\r\n                message: 'The array does not appear to be a firestore document or FireItem since it lacks firestoreMetadata',\r\n            };\r\n            throw error;\r\n        }\r\n        const batch = this.getBatchFromMoveItemInIndexedDocs(items, fromIndex, toIndex, useCopy);\r\n        return this.batchCommit$(batch);\r\n    }\r\n    /**\r\n     * Does the heavy lifting when it comes to updating multiple docs to change their index.\r\n     * Not called directly.\r\n     *\r\n     * @param items array of FireItem<A> docs with index variables to be updated\r\n     * @param fromIndex\r\n     * @param toIndex\r\n     * @param useCopy if true the given array will not be updated\r\n     * @protected\r\n     */\r\n    getBatchFromMoveItemInIndexedDocs(items, fromIndex, toIndex, useCopy = false) {\r\n        const lowestIndex = Math.min(fromIndex, toIndex);\r\n        const batch = writeBatch(this.fs.firestore);\r\n        if (fromIndex == null || toIndex == null || fromIndex === toIndex) { // we didnt really move anything\r\n            return batch;\r\n        }\r\n        let usedItems;\r\n        if (useCopy) {\r\n            usedItems = Object.assign([], items);\r\n        }\r\n        else {\r\n            usedItems = items;\r\n        }\r\n        moveItemInArray(usedItems, fromIndex, toIndex);\r\n        const listSliceToUpdate = usedItems.slice(lowestIndex);\r\n        let i = lowestIndex;\r\n        for (const item of listSliceToUpdate) {\r\n            if (!useCopy) { // this is just so that the given array's index is also updated immediately\r\n                item.index = i;\r\n            }\r\n            const ref = getRefFromPath(item.firestoreMetadata.path, this.fs.firestore);\r\n            batch.update(ref, { index: i });\r\n            i++;\r\n        }\r\n        return batch;\r\n    }\r\n    /**\r\n     * Use when you wish to delete an indexed document and have the remaining documents update their indices to reflect the change.\r\n     *\r\n     * @param items array of FireItem<A> docs with index variables to be updated\r\n     * @param indexToDelete\r\n     * @param subCollectionQueries\r\n     * @param useCopy\r\n     */\r\n    deleteIndexedItemInArray$(items, indexToDelete, subCollectionQueries = [], useCopy = false) {\r\n        let usedItems;\r\n        if (useCopy) {\r\n            usedItems = Object.assign([], items);\r\n        }\r\n        else {\r\n            usedItems = items;\r\n        }\r\n        const itemToDelete = usedItems[indexToDelete];\r\n        // get the delete batch that also contains any sub collections of the item\r\n        return this.getDeleteBatch$(itemToDelete.firestoreMetadata.ref, subCollectionQueries).pipe(map((batch) => {\r\n            // sort and remove the item from the usedItems and then add the update index to the batch\r\n            usedItems.sort(item => item.index); // make sure array is sorted by index\r\n            usedItems.splice(indexToDelete, 1);\r\n            this.getBatchFromUpdateIndexFromListOfDocs(usedItems, batch);\r\n            return batch;\r\n        }), switchMap((batch) => this.batchCommit$(batch)));\r\n    }\r\n    /**\r\n     * Use when you wish to delete several indexed documents and have the remaining documents update their indices to reflect the change.\r\n     *\r\n     * @param items array of FireItem<A> docs with index variables to be updated\r\n     * @param indicesToDelete\r\n     * @param subCollectionQueries\r\n     * @param useCopy\r\n     */\r\n    deleteIndexedItemsInArray$(items, indicesToDelete, subCollectionQueries = [], useCopy = false) {\r\n        let usedItems;\r\n        if (useCopy) {\r\n            usedItems = Object.assign([], items);\r\n        }\r\n        else {\r\n            usedItems = items;\r\n        }\r\n        usedItems.sort(item => item.index); // make sure array is sorted by index\r\n        const itemsToDelete = usedItems.filter((item, i) => {\r\n            return indicesToDelete.findIndex(_i => _i === i) !== -1;\r\n        });\r\n        // iterate in reverse so as to not change the indices,\r\n        // the indices to delete must also be sorted\r\n        indicesToDelete.sort();\r\n        for (let i = indicesToDelete.length - 1; i >= 0; i--) {\r\n            usedItems.splice(indicesToDelete[i], 1);\r\n        }\r\n        const docRefsObs$ = [];\r\n        // get the docRefs for items to be deleted including the ones in the subCollections\r\n        itemsToDelete.forEach(itemToDelete => {\r\n            const obs$ = this.getDocumentReferencesDeep$(itemToDelete.firestoreMetadata.ref, subCollectionQueries).pipe(take(1));\r\n            docRefsObs$.push(obs$);\r\n        });\r\n        return forkJoin(docRefsObs$).pipe(take(1), map((listOfDocRefs) => {\r\n            // concat all the separate docRefs lists into one array of docRefs\r\n            let docRefs = [];\r\n            listOfDocRefs.forEach(refs => {\r\n                docRefs = docRefs.concat(refs);\r\n            });\r\n            return docRefs;\r\n        }), map((docRefs) => this.getDeleteMultipleSimpleBatch(docRefs)), map((batch) => this.getBatchFromUpdateIndexFromListOfDocs(usedItems, batch)), switchMap((batch) => this.batchCommit$(batch)));\r\n    }\r\n    /**\r\n     * Run this on collections with a fixed order using an index: number attribute;\r\n     * This will update that index with the index in the collectionData, so it should be sorted by index first.\r\n     * Basically needs to be run after a delete\r\n     *\r\n     * @param items\r\n     * @param batch\r\n     * @protected\r\n     */\r\n    getBatchFromUpdateIndexFromListOfDocs(items, batch = writeBatch(this.fs.firestore)) {\r\n        items.forEach((item, index) => {\r\n            if (item.index !== index) {\r\n                item.index = index; // this is just so that the given array's index is also updated immediately\r\n                const ref = getRefFromPath(item.firestoreMetadata.path, this.fs.firestore);\r\n                batch.update(ref, { index });\r\n            }\r\n        });\r\n        return batch;\r\n    }\r\n    transferItemInIndexedDocs(previousArray, currentArray, previousIndex, currentIndex, currentArrayName, additionalDataUpdateOnMovedItem, isUpdateModifiedDateOnMovedItem = true, useCopy = false) {\r\n        const batch = this.getBatchFromTransferItemInIndexedDocs(previousArray, currentArray, previousIndex, currentIndex, currentArrayName, additionalDataUpdateOnMovedItem, isUpdateModifiedDateOnMovedItem, useCopy);\r\n        return this.batchCommit$(batch);\r\n    }\r\n    /* ----------  DELETE -------------- */\r\n    /**\r\n     * Delete Document and child documents\r\n     *\r\n     * @param docRef DocumentReference that is to be deleted\r\n     * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n     */\r\n    delete$(docRef, subCollectionQueries = []) {\r\n        if (subCollectionQueries == null || subCollectionQueries.length === 0) {\r\n            // not deep so just do a normal doc delete\r\n            return this.fs.delete(docRef);\r\n        }\r\n        return this.getDocumentReferencesDeep$(docRef, subCollectionQueries).pipe(switchMap((docRefList) => this.deleteMultipleSimple$(docRefList)));\r\n    }\r\n    /**\r\n     * Returns WriteBatch that is set to delete Document and child documents of given docRef\r\n     *\r\n     * @param docRef DocumentReference that is to be deleted\r\n     * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n     * @param batch\r\n     */\r\n    getDeleteBatch$(docRef, subCollectionQueries = [], batch = writeBatch(this.fs.firestore)) {\r\n        if (subCollectionQueries == null || subCollectionQueries.length === 0) {\r\n            // not deep so just do a normal doc delete\r\n            batch.delete(docRef);\r\n            return of(batch);\r\n        }\r\n        return this.getDocumentReferencesDeep$(docRef, subCollectionQueries).pipe(map((docRefs) => this.getDeleteMultipleSimpleBatch(docRefs)), take(1));\r\n    }\r\n    deleteMultipleByPaths$(docPaths) {\r\n        const docRefs = docPaths.map(path => getRefFromPath(path, this.fs.firestore));\r\n        return this.deleteMultipleSimple$(docRefs);\r\n    }\r\n    /**\r\n     * Delete Documents and child documents\r\n     *\r\n     * @param docRefs - A list of DocumentReference that are to be deleted\r\n     * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n     */\r\n    deleteMultiple$(docRefs, subCollectionQueries = []) {\r\n        if (subCollectionQueries == null || subCollectionQueries.length === 0) {\r\n            return this.deleteMultipleSimple$(docRefs);\r\n        }\r\n        const deepDocRefs$ = [];\r\n        docRefs.forEach(docRef => {\r\n            const docRefs$ = this.getDocumentReferencesDeep$(docRef, subCollectionQueries);\r\n            deepDocRefs$.push(docRefs$);\r\n        });\r\n        return combineLatest(deepDocRefs$).pipe(\r\n        // tap(lists => console.log(lists)),\r\n        map((lists) => {\r\n            let mainDocRefList = [];\r\n            lists.forEach(list => {\r\n                mainDocRefList = mainDocRefList.concat(list);\r\n            });\r\n            return mainDocRefList;\r\n        }), \r\n        // tap(lists => console.log(lists)),\r\n        switchMap((docRefList) => this.deleteMultipleSimple$(docRefList)));\r\n    }\r\n    /**\r\n     * Delete all documents and sub collections as specified in subCollectionQueries.\r\n     * Not very efficient and causes a lot of db reads.\r\n     * If possible use the firebase CLI or the console instead when deleting large collections.\r\n     *\r\n     * @param collectionRef\r\n     * @param subCollectionQueries\r\n     */\r\n    deleteCollection$(collectionRef, subCollectionQueries = []) {\r\n        return this.getDocumentReferencesFromCollectionRef$(collectionRef, subCollectionQueries).pipe(switchMap(docRefs => this.deleteMultiple$(docRefs))).pipe(take(1));\r\n    }\r\n    /**\r\n     * Delete firestore document by path\r\n     * Convenience method in case we do not have direct access to the AngularFirestoreDocument reference\r\n     *\r\n     * @param docPath A string representing the path of the referenced document (relative to the root of the database).\r\n     * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n     */\r\n    deleteDocByPath$(docPath, subCollectionQueries = []) {\r\n        const docRef = getRefFromPath(docPath, this.fs.firestore);\r\n        return this.delete$(docRef, subCollectionQueries);\r\n    }\r\n    /**\r\n     * Delete document by FirestoreItem\r\n     *\r\n     * Convenience method that works the same as deleteDeep$ but takes a FirestoreItem to be deleted\r\n     *\r\n     * @param item FirestoreItem to be deleted\r\n     * @param subCollectionQueries if the document has child documents the subCollectionQueries are needed to locate them\r\n     */\r\n    deleteItem$(item, subCollectionQueries = []) {\r\n        const docRefs = this.getDocumentReferencesFromItem(item, subCollectionQueries);\r\n        return this.deleteMultipleSimple$(docRefs).pipe(\r\n        // catchError((err) => { // TODO super ugly and I dont know why this error is thrown..still works\r\n        //   if (err === 'Document Does not exists') { return of(null); }\r\n        //   else { throw err; }\r\n        // }),\r\n        take(1));\r\n    }\r\n    cleanExtrasFromData(data, subCollectionWriters = [], additionalFieldsToRemove = []) {\r\n        // const dataToBeCleaned = cloneDeep(data); /* clone data so we dont modify the original */\r\n        // const dataToBeCleaned = data;\r\n        if (Array.isArray(data)) {\r\n            const cleanDatas = [];\r\n            data.forEach(d => {\r\n                cleanDatas.push(this.removeDataExtrasRecursiveHelper(d, subCollectionWriters, additionalFieldsToRemove));\r\n            });\r\n            return cleanDatas;\r\n        }\r\n        else {\r\n            return this.removeDataExtrasRecursiveHelper(data, subCollectionWriters, additionalFieldsToRemove);\r\n        }\r\n    }\r\n    /* ----------  PROTECTED METHODS -------------- */\r\n    /**\r\n     * Same as AngularFirestoreDocument.snapshotChanges but it adds the properties in FirebaseDbItem\r\n     * and also allows for to choose action to take when document does not exist\r\n     *\r\n     * Important to understand this is will trigger for every change/update on the document we are listening to.\r\n     *\r\n     * @param docRef DocumentReference that will be listened to\r\n     * @param actionIfNotExist Action to take if document does not exist\r\n     */\r\n    listenForDocSimple$(docRef, actionIfNotExist = DocNotExistAction.RETURN_ALL_BUT_DATA) {\r\n        return this.fs.doc(docRef).pipe(tap((snapshot) => {\r\n            if (!snapshot.exists() && actionIfNotExist === DocNotExistAction.THROW_DOC_NOT_FOUND) {\r\n                const error = {\r\n                    name: 'FirebaseErrorExt',\r\n                    code: 'not-found',\r\n                    message: 'Document not found and actionIfNotExist is set to THROW_DOC_NOT_FOUND',\r\n                    docRef\r\n                };\r\n                throw error;\r\n            }\r\n        }), filter((snapshot) => {\r\n            return !(snapshot.exists() && actionIfNotExist === DocNotExistAction.FILTER);\r\n        }), map((snapshot) => {\r\n            console.log(snapshot.exists());\r\n            if (snapshot.exists() || actionIfNotExist === DocNotExistAction.RETURN_ALL_BUT_DATA) {\r\n                const data = snapshot.data();\r\n                const firestoreMetadata = {\r\n                    id: snapshot.id,\r\n                    ref: snapshot.ref,\r\n                    path: docRef.path,\r\n                    isExists: snapshot.exists(),\r\n                    snapshotMetadata: snapshot.metadata\r\n                };\r\n                return Object.assign(Object.assign({}, data), { firestoreMetadata });\r\n            }\r\n            else if (actionIfNotExist === DocNotExistAction.RETURN_NULL) { /* doc doesn't exist */\r\n                return null;\r\n            }\r\n            return null;\r\n        }), map((data) => {\r\n            if (data != null) {\r\n                return convertTimestampToDate(data);\r\n            }\r\n            else {\r\n                return data;\r\n            }\r\n        }));\r\n    }\r\n    /**\r\n     * Listens for single collection and returns an array of documents as FireItem<T>[]\r\n     * Used internally, please use listenForCollection$() instead.\r\n     *\r\n     * @param _query the Query which will be listened to\r\n     * @protected\r\n     */\r\n    listenForCollectionSimple$(_query) {\r\n        /**\r\n         * Returns an observable that will emit whenever the ref changes in any way.\r\n         * Also adds the id and ref to the object.\r\n         */\r\n        return this.fs.collection(_query).pipe(map((snap) => {\r\n            return snap.docs.map(snapshot => {\r\n                const data = snapshot.data();\r\n                const id = snapshot.id;\r\n                const ref = snapshot.ref;\r\n                const path = ref.path;\r\n                const snapshotMetadata = snapshot.metadata;\r\n                const firestoreMetadata = {\r\n                    id,\r\n                    path,\r\n                    ref,\r\n                    snapshotMetadata,\r\n                    isExists: true\r\n                };\r\n                return Object.assign(Object.assign({}, data), { firestoreMetadata });\r\n            });\r\n        }), map((datas) => datas.map(data => {\r\n            convertTimestampToDate(data);\r\n            return data;\r\n        })));\r\n    }\r\n    /**\r\n     * Used internally for both listenForDoc and listenForCollection in order to recursively get collections.\r\n     *\r\n     * Please use listenForDoc or listenForCollection.\r\n     *\r\n     * @param item\r\n     * @param subCollectionQueries\r\n     * @protected\r\n     */\r\n    listenForCollectionsDeep(item, subCollectionQueries = []) {\r\n        if (item == null) {\r\n            return of([item]);\r\n        }\r\n        if (subCollectionQueries.length <= 0) {\r\n            return of([item]);\r\n        }\r\n        const collectionListeners = [];\r\n        /* Iterate over each sub collection we have given and create collection listeners*/\r\n        subCollectionQueries.forEach(subCollectionQuery => {\r\n            const queryContainer = new QueryContainer(getSubCollection(item.firestoreMetadata.ref, subCollectionQuery.name));\r\n            if (subCollectionQuery.queryConstraints) {\r\n                queryContainer.queryConstraints = subCollectionQuery.queryConstraints;\r\n                // collectionRef = subCollectionQuery.queryFn(collectionRef) as CollectionReference;\r\n            }\r\n            // if (subCollectionQuery.queryFn) {\r\n            //   collectionRef = subCollectionQuery.queryFn(collectionRef) as CollectionReference;\r\n            // }\r\n            const collectionListener = this.listenForCollectionSimple$(queryContainer.query).pipe(\r\n            // filter(docs => docs.length > 0), // skip empty collections or if the subCollectionQuery doesnt exist\r\n            /* Uncomment to see data on each update */\r\n            // tap(d => console.log(d)),\r\n            // filter(docs => docs != null),\r\n            /* Listen For and Add any Potential Sub Docs*/\r\n            // @ts-ignore // TODO fix this so that I can remove the ts-ignore\r\n            mergeMap((items) => {\r\n                if (!subCollectionQuery.subCollections) {\r\n                    return of(items);\r\n                }\r\n                const docListeners = [];\r\n                items = items.filter(d => d != null); // filter out potential nulls\r\n                items.forEach((subItem) => {\r\n                    const subDocAndCollections$ = this.listenForCollectionsDeep(subItem, subCollectionQuery.subCollections);\r\n                    docListeners.push(subDocAndCollections$);\r\n                });\r\n                if (docListeners.length <= 0) {\r\n                    return of([]);\r\n                } /* subCollectionQuery is empty or doesnt exist */\r\n                return combineLatest(docListeners).pipe(\r\n                // tap(val => console.log(val))\r\n                );\r\n            }), /* End of Listening for sub docs */ \r\n            /* If docs.length === 1 and the id is defaultDocId or the given docId it means we are in a sub subCollectionQuery\r\n            and we only care about the data. So we remove the array and just make it one object with the\r\n            subCollectionQuery name as key and docs[0] as value */\r\n            map((items) => {\r\n                const docId = subCollectionQuery.docId !== undefined ? subCollectionQuery.docId : this.defaultDocId;\r\n                if (items.length === 1 && items[0].firestoreMetadata.id === docId) {\r\n                    return { [subCollectionQuery.name]: items[0] };\r\n                }\r\n                else {\r\n                    return { [subCollectionQuery.name]: items };\r\n                }\r\n            }));\r\n            collectionListeners.push(collectionListener);\r\n        });\r\n        /* Finally return the combined collection listeners*/\r\n        // @ts-ignore\r\n        return combineLatest(collectionListeners).pipe(map((collectionDatas) => {\r\n            // map((collectionDatas) => {\r\n            const datasMap = {};\r\n            collectionDatas.forEach((collectionData) => {\r\n                for (const [collectionName, items] of Object.entries(collectionData)) {\r\n                    datasMap[collectionName] = items;\r\n                }\r\n            });\r\n            return datasMap;\r\n        }), map((data) => {\r\n            return Object.assign(Object.assign({}, item), data);\r\n        }));\r\n    }\r\n    /**\r\n     * DO NOT CALL THIS METHOD, meant to be used solely by listenForDocAndSubCollections$\r\n     */\r\n    listenForDocDeepRecursiveHelper$(docRef, subCollectionQueries = [], actionIfNotExist = DocNotExistAction.RETURN_NULL) {\r\n        /* Listen for the docFs*/\r\n        return this.listenForDocSimple$(docRef, actionIfNotExist).pipe(mergeMap((item) => {\r\n            if (item === null) {\r\n                return of(item);\r\n            }\r\n            if (subCollectionQueries.length <= 0) {\r\n                return of(item);\r\n            }\r\n            return this.listenForCollectionsDeep(item, subCollectionQueries);\r\n        }));\r\n    }\r\n    /**\r\n     * A replacement/extension to the AngularFirestoreCollection.add.\r\n     * Does the same as AngularFirestoreCollection.add but can also add createdDate and modifiedDate and returns\r\n     * the data with the added properties in FirebaseDbItem\r\n     *\r\n     * Used internally\r\n     *\r\n     * @param data the data to be added to the document, cannot contain types firestore won't allow\r\n     * @param collectionRef the CollectionReference where the document should be added\r\n     * @param isAddDates if true adds modifiedDate and createdDate to the data\r\n     * @param id if given the added document will be given this id, otherwise a random unique id will be used.\r\n     */\r\n    addSimple$(data, collectionRef, isAddDates = true, id) {\r\n        // let dataToBeSaved: A = Object.assign({}, data);\r\n        let res$;\r\n        if (isAddDates) {\r\n            const date = new Date();\r\n            data = addCreatedDate(data, false, date);\r\n            data = addModifiedDate(data, false, date);\r\n        }\r\n        if (id !== undefined) {\r\n            const docRef = getDocRefWithId(collectionRef, id);\r\n            res$ = this.fs.set(docRef, data);\r\n        }\r\n        else {\r\n            res$ = this.fs.add(collectionRef, data);\r\n        }\r\n        // if (Array.isArray(data) && isAddDates) {\r\n        //   data = data.map(item => {\r\n        //     return {...item, modifiedDate: dataToBeSaved.modifiedDate, createdData: dataToBeSaved.createdData }\r\n        //   })\r\n        // }\r\n        res$ = res$.pipe(\r\n        // tap(() => this.snackBar.open('Success', 'Added', {duration: 1000})),\r\n        // tap(ref => console.log(ref)),\r\n        // tap(() => console.log(data)),\r\n        map((ref) => {\r\n            if (id === undefined && ref) {\r\n                const path = ref.path;\r\n                const firestoreMetadata = {\r\n                    id: ref.id,\r\n                    path,\r\n                    ref,\r\n                    isExists: true\r\n                };\r\n                return Object.assign(Object.assign({}, data), { firestoreMetadata });\r\n            }\r\n            else { // if id is defined it means we used docRef.set and ref is undefined\r\n                const path = collectionRef.path + '/' + id;\r\n                ref = getRefFromPath(path, this.fs.firestore);\r\n                const firestoreMetadata = {\r\n                    id: id,\r\n                    ref,\r\n                    path,\r\n                    isExists: true\r\n                };\r\n                return Object.assign(Object.assign({}, data), { firestoreMetadata });\r\n            }\r\n        }));\r\n        return res$.pipe(take(1));\r\n    }\r\n    /** Used internally for updates that doesn't affect child documents */\r\n    updateSimple$(data, docRef, isAddModifiedDate = true) {\r\n        if (isAddModifiedDate) {\r\n            data = addModifiedDate(data, false);\r\n        }\r\n        return this.fs.update(docRef, data);\r\n    }\r\n    /**\r\n     * DO NOT CALL THIS METHOD, used by update deep\r\n     */\r\n    updateDeepToBatchHelper(data, docRef, subCollectionWriters = [], isAddModifiedDate = true, batch) {\r\n        var _a, _b;\r\n        if (batch === undefined) {\r\n            batch = writeBatch(this.fs.firestore);\r\n        }\r\n        if (isAddModifiedDate) {\r\n            data = addModifiedDate(data, false);\r\n        }\r\n        const split = this.splitDataIntoCurrentDocAndSubCollections(data, subCollectionWriters);\r\n        const currentDoc = split.currentDoc;\r\n        const subCollections = split.subCollections;\r\n        // console.log(currentDoc, subCollections);\r\n        batch.update(docRef, currentDoc);\r\n        for (const [subCollectionKey, subDocUpdateValue] of Object.entries(subCollections)) {\r\n            let subSubCollectionWriters; // undefined if no subCollectionWriters\r\n            let subDocId;\r\n            if (subCollectionWriters) {\r\n                subSubCollectionWriters = (_a = subCollectionWriters.find(subColl => subColl.name === subCollectionKey)) === null || _a === void 0 ? void 0 : _a.subCollections;\r\n                subDocId = (_b = subCollectionWriters.find(subColl => subColl.name === subCollectionKey)) === null || _b === void 0 ? void 0 : _b.docId;\r\n            }\r\n            subDocId = subDocId !== undefined ? subDocId : this.defaultDocId; /* Set default if none given */\r\n            // const subDocFs = docRef.collection(subCollectionKey).doc(subDocId);\r\n            const subCollection = getSubCollection(docRef, subCollectionKey);\r\n            const subDocFs = getDocRefWithId(subCollection, subDocId);\r\n            batch = this.updateDeepToBatchHelper(subDocUpdateValue, subDocFs, subSubCollectionWriters, isAddModifiedDate, batch);\r\n        }\r\n        return batch;\r\n    }\r\n    /**\r\n     * Used mainly for drag and drop scenarios where we drag an item from one list to another and the the docs\r\n     * have an index value and a groupName.\r\n     *\r\n     * @param previousArray\r\n     * @param currentArray\r\n     * @param previousIndex\r\n     * @param currentIndex\r\n     * @param currentArrayName\r\n     * @param additionalDataUpdateOnMovedItem\r\n     * @param isUpdateModifiedDateOnMovedItem\r\n     * @param useCopy\r\n     * @protected\r\n     */\r\n    getBatchFromTransferItemInIndexedDocs(previousArray, currentArray, previousIndex, currentIndex, currentArrayName, additionalDataUpdateOnMovedItem, isUpdateModifiedDateOnMovedItem = true, useCopy = false) {\r\n        let usedPreviousArray;\r\n        let usedCurrentArray;\r\n        if (useCopy) {\r\n            usedPreviousArray = Object.assign([], previousArray);\r\n            usedCurrentArray = Object.assign([], currentArray);\r\n        }\r\n        else {\r\n            usedPreviousArray = previousArray;\r\n            usedCurrentArray = currentArray;\r\n        }\r\n        transferArrayItem(usedPreviousArray, usedCurrentArray, previousIndex, currentIndex);\r\n        const batch = writeBatch(this.fs.firestore);\r\n        if (additionalDataUpdateOnMovedItem !== undefined) {\r\n            const movedItem = usedCurrentArray[currentIndex];\r\n            const movedItemRef = movedItem.firestoreMetadata.ref;\r\n            const data = Object.assign(Object.assign({}, additionalDataUpdateOnMovedItem), { groupName: currentArrayName });\r\n            if (!useCopy) {\r\n                addDataToItem(movedItem, data, true);\r\n            }\r\n            if (isUpdateModifiedDateOnMovedItem) {\r\n                const date = new Date();\r\n                addModifiedDate(data, true, date);\r\n                if (!useCopy) {\r\n                    addModifiedDate(movedItem, true, date);\r\n                }\r\n            }\r\n            batch.update(movedItemRef, data);\r\n        }\r\n        const currentArraySliceToUpdate = usedCurrentArray.slice(currentIndex);\r\n        let i = currentIndex;\r\n        for (const item of currentArraySliceToUpdate) {\r\n            // @ts-ignore\r\n            batch.update(item.firestoreMetadata.ref, { index: i });\r\n            if (!useCopy) {\r\n                item.index = i;\r\n            }\r\n            i++;\r\n        }\r\n        const prevArraySliceToUpdate = usedPreviousArray.slice(previousIndex);\r\n        i = previousIndex;\r\n        for (const item of prevArraySliceToUpdate) {\r\n            // @ts-ignore\r\n            batch.update(item.firestoreMetadata.ref, { index: i });\r\n            if (!useCopy) {\r\n                item.index = i;\r\n            }\r\n            i++;\r\n        }\r\n        return batch;\r\n    }\r\n    /**\r\n     * Delete Documents\r\n     *\r\n     * @param docRefs - A list of DocumentReference that are to be deleted\r\n     */\r\n    deleteMultipleSimple$(docRefs) {\r\n        const batch = this.getDeleteMultipleSimpleBatch(docRefs);\r\n        return this.batchCommit$(batch);\r\n    }\r\n    getDeleteMultipleSimpleBatch(docRefs, batch = writeBatch(this.fs.firestore)) {\r\n        docRefs.forEach((docRef) => {\r\n            batch.delete(docRef);\r\n        });\r\n        return batch;\r\n    }\r\n    /**\r\n     * Recursive method to clean FirestoreBaseItem properties from the dbItem\r\n     *\r\n     * @param dbItem the data to be cleaned\r\n     * @param subCollectionWriters list of SubCollectionWriters to handle sub collections\r\n     * @param additionalFieldsToRemove\r\n     */\r\n    removeDataExtrasRecursiveHelper(dbItem, subCollectionWriters = [], additionalFieldsToRemove = []) {\r\n        // const extraPropertyNames: string[] = Object.getOwnPropertyNames(new DbItemExtras());\r\n        const extraPropertyNames = ['firestoreMetadata'].concat(additionalFieldsToRemove);\r\n        /* Current level delete */\r\n        for (const extraPropertyName of extraPropertyNames) {\r\n            delete dbItem[extraPropertyName];\r\n        }\r\n        subCollectionWriters.forEach(col => {\r\n            if (Array.isArray(dbItem[col.name])) { /* property is array so will contain multiple docs */\r\n                const docs = dbItem[col.name];\r\n                docs.forEach((d, i) => {\r\n                    if (col.subCollections) {\r\n                        this.removeDataExtrasRecursiveHelper(d, col.subCollections, additionalFieldsToRemove);\r\n                    }\r\n                    else {\r\n                        /*  */\r\n                        for (const extraPropertyName of extraPropertyNames) {\r\n                            delete dbItem[col.name][i][extraPropertyName];\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            else { /* not an array so a single doc*/\r\n                if (col.subCollections) {\r\n                    this.removeDataExtrasRecursiveHelper(dbItem[col.name], col.subCollections, additionalFieldsToRemove);\r\n                }\r\n                else {\r\n                    for (const extraPropertyName of extraPropertyNames) {\r\n                        delete dbItem[col.name][extraPropertyName];\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return dbItem;\r\n    }\r\n    /**\r\n     * Returns an Observable containing a list of DocumentReference found under the given docRef using the SubCollectionQuery[]\r\n     * Mainly used to delete a docFs and its sub docs\r\n     * @param ref: DocumentReference | CollectionReference\r\n     * @param subCollectionQueries: SubCollectionQuery[]\r\n     */\r\n    getDocumentReferencesDeep$(ref, subCollectionQueries = []) {\r\n        if (ref instanceof DocumentReference) {\r\n            return this.getDocumentReferencesFromDocRef$(ref, subCollectionQueries);\r\n        }\r\n        else { // CollectionReference\r\n            return this.getDocumentReferencesFromCollectionRef$(ref, subCollectionQueries);\r\n        }\r\n    }\r\n    getDocumentReferencesFromDocRef$(docRef, subCollectionQueries = []) {\r\n        return this.listenForDoc$(docRef, subCollectionQueries).pipe(take(1), map(item => this.getPathsFromItemDeepRecursiveHelper(item, subCollectionQueries)), \r\n        // tap(pathList => console.log(pathList)),\r\n        map((pathList) => {\r\n            return pathList\r\n                .map(path => getRefFromPath(path, this.fs.firestore));\r\n        }));\r\n    }\r\n    getDocumentReferencesFromCollectionRef$(collectionRef, subCollectionQueries = []) {\r\n        return this.listenForCollectionSimple$(collectionRef).pipe(\r\n        // @ts-ignore\r\n        take(1), mergeMap((items) => {\r\n            let docListeners;\r\n            docListeners = items.map(item => this.listenForDoc$(item.firestoreMetadata.ref, subCollectionQueries));\r\n            return combineLatest(docListeners);\r\n        }), map((items) => {\r\n            let paths = [];\r\n            items.forEach(item => {\r\n                paths = paths.concat(this.getPathsFromItemDeepRecursiveHelper(item, subCollectionQueries));\r\n            });\r\n            return paths;\r\n        }), map((pathList) => {\r\n            return pathList\r\n                .map(path => getRefFromPath(path, this.fs.firestore));\r\n        }));\r\n    }\r\n    /**\r\n     * Used by deleteDeepByItem$ to get all the AngularFirestoreDocuments to be deleted\r\n     * including child documents using SubCollectionQueries\r\n     *\r\n     * Internal use\r\n     * @param item FirestoreItem from where we get the AngularFirestoreDocuments\r\n     * @param subCollectionQueries if the dbItem has child documents the subCollectionQueries are needed to locate them\r\n     */\r\n    getDocumentReferencesFromItem(item, subCollectionQueries = []) {\r\n        const paths = this.getPathsFromItemDeepRecursiveHelper(item, subCollectionQueries);\r\n        return paths.map(path => getRefFromPath(path, this.fs.firestore));\r\n    }\r\n    /**\r\n     * DO NOT CALL THIS METHOD, its meant as a support method for getDocs$\r\n     */\r\n    getPathsFromItemDeepRecursiveHelper(item, subCollectionQueries = []) {\r\n        if (subCollectionQueries == null || subCollectionQueries.length === 0) {\r\n            return [item.firestoreMetadata.path];\r\n        }\r\n        let pathList = [];\r\n        pathList.push(item.firestoreMetadata.path);\r\n        subCollectionQueries.forEach(col => {\r\n            if (Array.isArray(item[col.name]) && !col.docId) {\r\n                /* property is array and not using docId so will contain multiple docs */\r\n                const items = item[col.name];\r\n                items.forEach(subItem => {\r\n                    if (col.subCollections) {\r\n                        pathList = pathList.concat(this.getPathsFromItemDeepRecursiveHelper(subItem, col.subCollections));\r\n                    }\r\n                    else {\r\n                        pathList.push(subItem.firestoreMetadata.path);\r\n                    }\r\n                });\r\n            }\r\n            else { /* not an array so a single doc*/\r\n                if (col.subCollections) {\r\n                    pathList = pathList.concat(this.getPathsFromItemDeepRecursiveHelper(item, col.subCollections));\r\n                }\r\n                else {\r\n                    const subItem = item[col.name];\r\n                    if (subItem != null && 'path' in subItem.firestoreMetadata) {\r\n                        pathList.push(subItem.firestoreMetadata.path);\r\n                    }\r\n                    // const path = (dbItem[col.name] as FirestoreItem).path;\r\n                }\r\n            }\r\n        });\r\n        return pathList;\r\n    }\r\n    /**\r\n     * DO  NOT  CALL THIS METHOD, used in addDeep and updateDeep to split the data into currentDoc and subCollections\r\n     * Only goes one sub level deep;\r\n     */\r\n    splitDataIntoCurrentDocAndSubCollections(data, subCollectionWriters = []) {\r\n        /* Split data into current doc and sub collections */\r\n        let currentDoc = {};\r\n        const subCollections = {};\r\n        /* Check if the key is in subCollections, if it is place it in subCollections else place it in currentDoc */\r\n        // not array so object\r\n        for (const [key, value] of Object.entries(data)) {\r\n            // console.log(key, value);\r\n            if (subCollectionWriters && subCollectionWriters.length > 0) {\r\n                const subCollectionWriter = subCollectionWriters.find(subColl => subColl.name === key);\r\n                if (subCollectionWriter) {\r\n                    subCollections[key] = value;\r\n                }\r\n                else {\r\n                    currentDoc[key] = value;\r\n                }\r\n            }\r\n            else {\r\n                currentDoc = data;\r\n            }\r\n        }\r\n        return {\r\n            currentDoc,\r\n            subCollections\r\n        };\r\n    }\r\n    /**\r\n     * Turn a batch into an Observable instead of Promise.\r\n     *\r\n     * For some reason angularfire returns a promise on batch.commit() instead of an observable like for\r\n     * everything else.\r\n     *\r\n     * This method turns it into an observable\r\n     */\r\n    batchCommit$(batch) {\r\n        return from(batch.commit()).pipe(take(1));\r\n    }\r\n}\r\n/**\r\n * Firebase version 9 changed the query syntax\r\n * The new syntax broken the ability to chain queries like this:\r\n *\r\n * collectionRef.where('foo', '==', 123).limit(10)..returns the collection ref\r\n *\r\n * now instead you must write it like this, query(collectionRef, where('foo', '==', 123), limit(10))...returns a Query\r\n *\r\n * which is ugly and make you loose the information that was present in the collectionRef since a Query is returned instead,\r\n * which holds less information than a CollectionReference.\r\n *\r\n * This Container is meant to allow you to chain queries, like before version 9 and also retain the information in\r\n * the original CollectionReference\r\n */\r\nclass QueryContainer {\r\n    constructor(ref) {\r\n        this.ref = ref;\r\n        this.queryConstraints = [];\r\n    }\r\n    /** factory method to create container from path */\r\n    static fromPath(firestore, path) {\r\n        const ref = collection(firestore, path);\r\n        return new this(ref);\r\n    }\r\n    /** Returns the query with all the query constraints */\r\n    get query() {\r\n        return query(this.ref, ...this.queryConstraints);\r\n    }\r\n    /** Calls the firebase getDocs() method and listens for the documents in the query. */\r\n    getDocs$() {\r\n        return from(getDocs(this.query));\r\n    }\r\n    where(fieldPath, opStr, value) {\r\n        this.queryConstraints.push(where(fieldPath, opStr, value));\r\n        return this;\r\n    }\r\n    orderBy(fieldPath, directionStr) {\r\n        this.queryConstraints.push(orderBy(fieldPath, directionStr));\r\n        return this;\r\n    }\r\n    limit(_limit) {\r\n        this.queryConstraints.push(limit(_limit));\r\n        return this;\r\n    }\r\n    limitToLast(_limit) {\r\n        this.queryConstraints.push(limitToLast(_limit));\r\n        return this;\r\n    }\r\n    startAt(snapshot, ...fieldValues) {\r\n        if (snapshot) {\r\n            this.queryConstraints.push(startAt(snapshot));\r\n        }\r\n        else if (fieldValues) {\r\n            this.queryConstraints.push(startAt(...fieldValues));\r\n        }\r\n        return this;\r\n    }\r\n    startAfter(snapshot, ...fieldValues) {\r\n        if (snapshot) {\r\n            this.queryConstraints.push(startAfter(snapshot));\r\n        }\r\n        else if (fieldValues) {\r\n            this.queryConstraints.push(startAfter(...fieldValues));\r\n        }\r\n        return this;\r\n    }\r\n    endAt(snapshot, ...fieldValues) {\r\n        if (snapshot) {\r\n            this.queryConstraints.push(endAt(snapshot));\r\n        }\r\n        else if (fieldValues) {\r\n            this.queryConstraints.push(endAt(...fieldValues));\r\n        }\r\n        return this;\r\n    }\r\n    endBefore(snapshot, ...fieldValues) {\r\n        if (snapshot) {\r\n            this.queryConstraints.push(endBefore(snapshot));\r\n        }\r\n        else if (fieldValues) {\r\n            this.queryConstraints.push(endBefore(...fieldValues));\r\n        }\r\n        return this;\r\n    }\r\n}\n\nconst nop = () => tap(noop);\r\n/**\r\n * Takes a key/value object of observables or tuples:\r\n *\r\n * ```\r\n * {\r\n *  obs1: of(123),\r\n *  obs2: [of(\"value\").pipe(delay(1000)), \"startWith value\"],\r\n * }\r\n * ```\r\n *\r\n * and every time one of the source observables emits, emits an object\r\n * with the latest value from all observables:\r\n *\r\n * ```\r\n * {\r\n *  obs1: 123,\r\n *  obs2: \"startWith value\",\r\n * }\r\n * ```\r\n */\r\nconst combineLatestToObject = (observables) => {\r\n    const keys = Object.keys(observables);\r\n    return combineLatest(keys.map(k => {\r\n        const obs = observables[k];\r\n        return Array.isArray(obs)\r\n            ? obs[0].pipe(startWith(obs[1]))\r\n            : obs.pipe(nop());\r\n    })).pipe(map(b => b.reduce((acc, val, i) => (Object.assign(Object.assign({}, acc), { [keys[i]]: val })), {})));\r\n};\n\nclass FirestoreWrapper {\r\n    /**\r\n     * Uses firebase/firestore directly\r\n     * Simply makes the returned Promises into Observables\r\n     */\r\n    constructor(firebaseApp) {\r\n        this.firebaseApp = firebaseApp;\r\n    }\r\n    get firestore() {\r\n        return getFirestore(this.firebaseApp);\r\n    }\r\n    // doc\r\n    doc(docRef) {\r\n        return from(getDoc(docRef));\r\n    }\r\n    add(collectionRef, data) {\r\n        return from(addDoc(collectionRef, data)).pipe(take(1));\r\n    }\r\n    set(docRef, data, options) {\r\n        if (options) {\r\n            return from(setDoc(docRef, data, options)).pipe(take(1));\r\n        }\r\n        else {\r\n            return from(setDoc(docRef, data)).pipe(take(1));\r\n        }\r\n    }\r\n    delete(docRef) {\r\n        return from(deleteDoc(docRef)).pipe(take(1));\r\n    }\r\n    update(docRef, data, options) {\r\n        return from(updateDoc(docRef, data)).pipe(take(1));\r\n    }\r\n    collection(q) {\r\n        return from(getDocs(q));\r\n    }\r\n}\n\n/**\r\n * FirestoreExt Class that uses the FirestoreWrapper\r\n * Simply extend this class and give it an initialized FirebaseApp to use the FireStoreExtended methods.\r\n */\r\nclass FirestoreExt extends FirestoreExtended {\r\n    constructor(firebaseApp, defaultDocId = 'data') {\r\n        super(new FirestoreWrapper(firebaseApp), defaultDocId);\r\n    }\r\n}\n\n// import {InjectionToken} from '@angular/core';\r\n// import {FirebaseApp} from 'firebase/app';\r\nclass FirebaseConfig {\r\n}\r\n// export const FIREBASE_APP = new InjectionToken<FirebaseApp>('firebase_app.config');\r\nconst FIRESTORE_USE_EMULATOR = {\r\n    // useEmulator: false,\r\n    host: 'localhost',\r\n    port: 8080,\r\n};\r\n// export type FirestoreEmulatorConfig  = {\r\n//   useEmulator: boolean;\r\n//   emulatorHost: string;\r\n//   emulatorPort: 4200\r\n// }\n\nclass NgxFirebaseModule {\r\n    /**\r\n     * To be used as an Angular Module to inject the FirebaseConfig\r\n     * The FirebaseConfig is then used by NgxFirebaseService to create a Firebase app, this contains the websocket connection to firebase.\r\n     * We can then inject NgxRxFireService in to any service that wishes to use the Firebase app connection without creating\r\n     * additional connections.\r\n     * The purpose is simply to make sure that we only create a single Firebase App and a single connection\r\n     */\r\n    constructor(parentModule) {\r\n        if (parentModule) {\r\n            throw new Error('NgxFirestoreExtendedModule is already loaded. Import it in the AppModule only');\r\n        }\r\n    }\r\n    static forRoot(config) {\r\n        return {\r\n            ngModule: NgxFirebaseModule,\r\n            providers: [\r\n                { provide: FirebaseConfig, useValue: config }\r\n            ]\r\n        };\r\n    }\r\n}\r\nNgxFirebaseModule.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: NgxFirebaseModule, deps: [{ token: NgxFirebaseModule, optional: true, skipSelf: true }], target: i0.FactoryTarget.NgModule });\r\nNgxFirebaseModule.mod = i0.ngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: NgxFirebaseModule, imports: [CommonModule] });\r\nNgxFirebaseModule.inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: NgxFirebaseModule, imports: [[\r\n            CommonModule\r\n        ]] });\r\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: NgxFirebaseModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [],\r\n                    imports: [\r\n                        CommonModule\r\n                    ]\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: NgxFirebaseModule, decorators: [{\r\n                        type: Optional\r\n                    }, {\r\n                        type: SkipSelf\r\n                    }] }];\r\n    } });\n\nclass NgxFirebaseService {\r\n    constructor(config, emulatorConfig) {\r\n        this.emulatorConfig = emulatorConfig;\r\n        if (!firebase.getApps().length) {\r\n            if (config) {\r\n                this.firebaseApp = initializeApp(config);\r\n            }\r\n            else {\r\n                throw new Error('No previous Firebase App initialized so please provide a FirebaseConfig');\r\n            }\r\n        }\r\n        else {\r\n            this.firebaseApp = firebase.getApps()[0]; // if already initialized, use that one\r\n        }\r\n        if (emulatorConfig) {\r\n            connectFirestoreEmulator(getFirestore(this.firebaseApp), emulatorConfig.host, emulatorConfig.port); // v9\r\n            // getFirestore(this.firebaseApp).useEmulator(emulatorConfig.host, emulatorConfig.port); // v8\r\n        }\r\n    }\r\n}\r\nNgxFirebaseService.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: NgxFirebaseService, deps: [{ token: FirebaseConfig, optional: true }, { token: FIRESTORE_USE_EMULATOR, optional: true }], target: i0.FactoryTarget.Injectable });\r\nNgxFirebaseService.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: NgxFirebaseService, providedIn: 'root' });\r\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: NgxFirebaseService, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: FirebaseConfig, decorators: [{\r\n                        type: Optional\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Optional\r\n                    }, {\r\n                        type: Inject,\r\n                        args: [FIRESTORE_USE_EMULATOR]\r\n                    }] }];\r\n    } });\n\nclass NgxFirestoreExtendedService {\r\n    constructor(ngxFirebaseService) {\r\n        this.ngxFirebaseService = ngxFirebaseService;\r\n        this.fireExt = new FirestoreExt(ngxFirebaseService.firebaseApp); /* inject Firebase App from NgxFirebaseService */\r\n    }\r\n    get firebaseApp() {\r\n        /** Convenience getter */\r\n        return this.ngxFirebaseService.firebaseApp;\r\n    }\r\n}\r\nNgxFirestoreExtendedService.fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: NgxFirestoreExtendedService, deps: [{ token: NgxFirebaseService }], target: i0.FactoryTarget.Injectable });\r\nNgxFirestoreExtendedService.prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: NgxFirestoreExtendedService, providedIn: 'root' });\r\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: NgxFirestoreExtendedService, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: NgxFirebaseService }]; } });\n\n/*\r\n * Public API Surface of firestore-extended.ts\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { DocNotExistAction, FIRESTORE_USE_EMULATOR, FirebaseConfig, FirestoreExt, FirestoreExtended, FirestoreWrapper, NgxFirebaseModule, NgxFirebaseService, NgxFirestoreExtendedService, QueryContainer, addCreatedBy, addCreatedDate, addDataToItem, addModifiedDate, combineLatestToObject, convertTimestampToDate, getDocRefWithId, getRefFromPath, getSubCollection };\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}
